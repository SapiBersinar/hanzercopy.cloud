<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jigsaw Puzzle Online</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-image: linear-gradient(to bottom right, #a78bfa, #818cf8, #6366f1);
            background-attachment: fixed;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }
        canvas {
            display: block;
            background-color: #ffffff;
            border: 3px solid #4f46e5;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: none; /* Penting untuk mencegah gulir saat menyeret pada sentuhan */
            user-select: none; /* Non-seleksi teks */
            transition: transform 0.5s ease-out, border 0.5s ease-out, box-shadow 0.5s ease-out;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            border: 2px solid #4f46e5;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        .btn-primary-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6);
            transition: background-image 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed);
        }
        .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #3730a3, #5b21b6);
            transform: scale(0.98);
        }
        .btn-gray {
            background-color: #6b7280;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-gray:hover {
            background-color: #4b5563;
        }
        .btn-gray:active {
            background-color: #374151;
            transform: scale(0.98);
        }
        .sample-image-container {
            width: 80px;
            height: 80px;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .sample-image-container:hover {
            transform: scale(1.05);
            border-color: #6366f1;
        }
        .sample-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .puzzle-solved-animation {
            animation: puzzle-bounce 0.5s ease-out forwards;
            border-color: #10b981;
            box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.7), 0 0 30px 10px rgba(16, 185, 129, 0.5);
        }
        @keyframes puzzle-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        .original-image-display-container {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 3xl;
        }
        .original-image-display-container.show {
            display: flex;
        }
        .original-image-display-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        .original-image-display-container button {
            margin-top: 0;
        }
        .main-content-hidden {
            display: none;
        }
    </style>
</head>
<body class="text-gray-900">

    <div id="mainContent" class="w-full max-w-3xl bg-white p-6 rounded-xl shadow-lg my-4">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-6">Jigsaw Puzzle Online</h1>

        <!-- Bagian Unggah Foto -->
        <div class="mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-gray-700 mb-2">Unggah Foto Anda:</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
        </div>

        <!-- Bagian Pilih Gambar Contoh -->
        <div class="mb-6 text-center">
            <label class="block text-lg font-medium text-gray-700 mb-2">Atau Pilih Gambar Contoh:</label>
            <div id="sampleImageContainer" class="flex flex-wrap justify-center gap-2">
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/1.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/1.jpg" alt="Contoh Gambar 0">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/2.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/2.jpg" alt="Contoh Gambar 1">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/3.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/3.jpg" alt="Contoh Gambar 2">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/4.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/4.jpg" alt="Contoh Gambar 3">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/5.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/5.png" alt="Contoh Gambar 4">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/5.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/5.jpg" alt="Contoh Gambar 5">
                </div>
            </div>
        </div>

        <!-- Pilihan Ukuran Grid -->
        <div class="mb-6 text-center">
            <label for="gridSizeSelect" class="block text-lg font-medium text-gray-700 mb-2">Pilih Ukuran Puzzle:</label>
            <select id="gridSizeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                <option value="3" selected>3x3</option>
                <option value="4">4x4</option>
                <option value="5">5x5</option>
                <option value="6">6x6</option>
                <option value="8">8x8</option>
            </select>
        </div>
        
        <!-- Penghitung Gerakan -->
        <div class="flex justify-center gap-8 mb-4 text-center">
            <div class="text-lg font-semibold text-gray-700">
                Gerakan: <span id="moveCounter" class="text-indigo-700">0</span>
            </div>
        </div>

        <!-- Tombol Aksi -->
        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="shuffleButton" class="btn-primary-gradient text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Acak
            </button>
            <button id="resetButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Reset Puzzle
            </button>
        </div>

        <!-- Area Canvas untuk Puzzle -->
        <div class="relative w-full max-w-full flex justify-center items-center overflow-hidden mb-6" style="min-height: 250px;">
            <canvas id="puzzleCanvas" class="w-full h-auto max-w-full"></canvas>
        </div>

        <!-- Tombol Lihat Gambar Asli -->
        <div class="text-center mt-4">
            <button id="viewOriginalImageButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Lihat Gambar Asli
            </button>
        </div>
        
        <!-- Pesan Informasi -->
        <p class="text-center text-gray-600 text-sm italic mt-4">Seret dan lepas potongan puzzle untuk menyatukannya.</p>
    </div>

    <!-- Message Box untuk Notifikasi -->
    <div id="messageBoxContainer"></div>

    <!-- Container untuk tampilan gambar asli -->
    <div id="originalImageDisplayContainer" class="original-image-display-container">
        <img id="fullImageDisplay" src="" alt="Gambar Asli">
        <button id="backToPuzzleButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md">
            Kembali ke Puzzle
        </button>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSelect = document.getElementById('gridSizeSelect');
        const shuffleButton = document.getElementById('shuffleButton');
        const resetButton = document.getElementById('resetButton');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const ctx = puzzleCanvas.getContext('2d');
        const messageBoxContainer = document.getElementById('messageBoxContainer');
        const moveCounterDisplay = document.getElementById('moveCounter');
        const viewOriginalImageButton = document.getElementById('viewOriginalImageButton');
        const originalImageDisplayContainer = document.getElementById('originalImageDisplayContainer');
        const fullImageDisplay = document.getElementById('fullImageDisplay');
        const backToPuzzleButton = document.getElementById('backToPuzzleButton');
        const mainContent = document.getElementById('mainContent');

        const sampleImageContainers = document.querySelectorAll('.sample-image-container');

        let originalImage = new Image();
        let puzzlePieces = [];
        let gridSize = parseInt(gridSizeSelect.value);
        let pieceWidth;
        let pieceHeight;
        let puzzleReady = false; // Indicates if puzzle pieces and canvas are ready for interaction
        let moves = 0;
        
        let draggedPiece = null;
        let offsetX, offsetY; // Offset within the piece for dragging
        const snapThreshold = 20; // Pixels to snap if close to correct position

        // Layout Constants for Canvas Areas
        const VERTICAL_SPACING_BETWEEN_AREAS = 80; // Increased spacing for more separation
        const TRAY_LABEL_OFFSET_Y = 25; // Y offset for "Nampan Potongan" label from tray top
        const TRAY_PADDING = 15; // Padding inside the tray area
        const ASSEMBLE_LABEL_COLOR = 'rgba(49, 46, 129, 0.5)'; // Softer color for "Susun di Sini"
        const LOCKED_PIECE_BORDER_COLOR = 'rgba(0, 0, 0, 0.8)'; // Black border
        const LOCKED_PIECE_SHADOW_COLOR = 'rgba(0, 0, 0, 0.6)'; // Black glow

        let mainPuzzleAreaDimension; // Side length of the square puzzle area
        let trayAreaTotalHeight;     // Total calculated height of the tray area
        let trayAreaStartY;          // Y-coordinate where tray area begins on canvas

        // =====================================================================
        // Fungsi Utilitas untuk Notifikasi (Pengganti alert())
        // =====================================================================
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p class="text-xl font-semibold mb-4">${message}</p>
                <button id="closeMessageBox" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300">Oke</button>
            `;
            
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            messageBoxContainer.appendChild(overlay);
            messageBoxContainer.appendChild(messageBox);

            document.getElementById('closeMessageBox').onclick = () => {
                messageBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Penanganan Unggah Gambar
        // =====================================================================
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    console.log('Image FileReader loaded data URL.');
                    originalImage.onload = () => {
                        console.log('Original image loaded from uploaded file.');
                        if (originalImage.width !== originalImage.height) {
                            showMessageBox("Gambar dipotong menjadi persegi (1:1) dari bagian tengah untuk puzzle.");
                        }
                        initializePuzzle();
                        if (puzzleReady) { // Only shuffle if initialization was successful
                            shufflePuzzle(); 
                        }
                    };
                    originalImage.onerror = () => {
                        console.error('Error loading uploaded image.');
                        showMessageBox("Gagal memuat gambar yang diunggah. Silakan coba file lain.");
                        puzzleReady = false; 
                        drawPuzzle(); // Draw placeholder text
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                console.log('No file selected for upload.');
            }
        });

        // =====================================================================
        // Penanganan Pilih Gambar Contoh
        // =====================================================================
        sampleImageContainers.forEach(container => {
            container.addEventListener('click', () => {
                const imageUrl = container.dataset.src;
                if (!imageUrl) return;

                console.log('Loading sample image:', imageUrl);
                originalImage.onload = () => {
                    console.log('Original image loaded from sample.');
                    initializePuzzle();
                    if (puzzleReady) { // Only shuffle if initialization was successful
                        shufflePuzzle(); 
                    }
                };
                originalImage.onerror = () => {
                    console.error('Error loading sample image:', imageUrl);
                    showMessageBox("Gagal memuat gambar contoh. Silakan coba lagi atau unggah gambar Anda sendiri.");
                    puzzleReady = false; 
                    drawPuzzle(); // Draw placeholder text
                };
                originalImage.src = imageUrl;
            });
        });

        // =====================================================================
        // Penanganan Perubahan Ukuran Grid (dengan Penyimpanan Lokal)
        // =====================================================================
        gridSizeSelect.addEventListener('change', (event) => {
            gridSize = parseInt(event.target.value);
            localStorage.setItem('jigsawGridSize', gridSize); // Save preference
            console.log('Ukuran grid diubah menjadi:', gridSize);
            // Inisialisasi ulang dengan gambar saat ini atau placeholder
            if (originalImage.src && originalImage.complete && originalImage.naturalWidth > 0) {
                initializePuzzle();
                if (puzzleReady) { // Hanya acak jika inisialisasi berhasil
                    shufflePuzzle(); 
                }
            } else {
                // Jika tidak ada gambar yang dimuat, perbarui placeholder dengan ukuran grid baru
                const placeholderSize = 600;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`;
                initializePuzzle(); // Panggil inisialisasi untuk mengatur ukuran kanvas untuk grid baru, meskipun tidak ada gambar asli
            }
        });

        // =====================================================================
        // Inisialisasi Puzzle (Menyesuaikan gambar ke 1:1, mengatur potongan, membuat kanvas cache)
        // =====================================================================
        function initializePuzzle() {
            console.log('Menginisialisasi puzzle...');
            const container = puzzleCanvas.parentElement;
            // Pastikan lebar minimum untuk maxCanvasWidth
            const maxCanvasWidth = Math.max(300, Math.min(container.clientWidth, window.innerHeight * 0.75)); 

            mainPuzzleAreaDimension = maxCanvasWidth; // Area puzzle utama berbentuk persegi
            
            pieceWidth = mainPuzzleAreaDimension / gridSize;
            pieceHeight = mainPuzzleAreaDimension / gridSize;

            // Validasi dimensi potongan - tambahkan fallback untuk `pieceWidth` dan `pieceHeight` juga
            if (isNaN(pieceWidth) || pieceWidth <= 0) pieceWidth = mainPuzzleAreaDimension / 3; // Fallback ke ukuran potongan 3x3
            if (isNaN(pieceHeight) || pieceHeight <= 0) pieceHeight = mainPuzzleAreaDimension / 3;

            const totalPieces = gridSize * gridSize;
            const piecesPerRowInTray = Math.floor((maxCanvasWidth - (2 * TRAY_PADDING)) / pieceWidth);
            const effectivePiecesPerRow = Math.max(1, piecesPerRowInTray); // Pastikan setidaknya 1 potongan per baris

            const requiredTrayRows = Math.ceil(totalPieces / effectivePiecesPerRow);
            
            // Hitung tinggi nampan berdasarkan potongan, label, dan padding
            trayAreaTotalHeight = (requiredTrayRows * pieceHeight) + (2 * TRAY_PADDING) + TRAY_LABEL_OFFSET_Y + TRAY_PADDING; 
            
            // Pastikan nampan memiliki tinggi minimum yang masuk akal
            trayAreaTotalHeight = Math.max(trayAreaTotalHeight, pieceHeight + (2 * TRAY_PADDING) + TRAY_LABEL_OFFSET_Y + TRAY_PADDING);
            
            puzzleCanvas.width = mainPuzzleAreaDimension;
            puzzleCanvas.height = mainPuzzleAreaDimension + VERTICAL_SPACING_BETWEEN_AREAS + trayAreaTotalHeight; // Tambahkan spasi
            
            trayAreaStartY = mainPuzzleAreaDimension + VERTICAL_SPACING_BETWEEN_AREAS; // Koordinat Y di mana area nampan dimulai di kanvas, disesuaikan untuk spasi

            // Hanya coba menggambar potongan gambar jika originalImage dimuat sepenuhnya
            // Gunakan naturalWidth/Height untuk mengkonfirmasi data gambar ada
            if (!originalImage.complete || originalImage.naturalWidth === 0 || originalImage.naturalHeight === 0) {
                console.warn('Gambar asli tidak lengkap atau tidak memiliki dimensi alami. Tidak dapat membuat potongan puzzle.');
                puzzleReady = false;
                drawPuzzle(); // Gambar teks placeholder
                return;
            }

            let sourceSize = Math.min(originalImage.naturalWidth, originalImage.naturalHeight);
            let offsetXImage = (originalImage.naturalWidth - sourceSize) / 2;
            let offsetYImage = (originalImage.naturalHeight - sourceSize) / 2;

            puzzlePieces = [];
            for (let i = 0; i < totalPieces; i++) {
                // Buat kanvas di luar layar untuk setiap potongan (optimasi kinerja)
                const cachedPieceCanvas = document.createElement('canvas');
                cachedPieceCanvas.width = pieceWidth;
                cachedPieceCanvas.height = pieceHeight;
                const pieceCtx = cachedPieceCanvas.getContext('2d');
                pieceCtx.drawImage(
                    originalImage,
                    offsetXImage + (sourceSize / gridSize) * (i % gridSize),
                    offsetYImage + (sourceSize / gridSize) * Math.floor(i / gridSize),
                    sourceSize / gridSize,
                    sourceSize / gridSize,
                    0, 0, // Gambar di (0,0) di kanvas kecilnya sendiri
                    pieceWidth, pieceHeight
                );

                puzzlePieces.push({
                    id: i,
                    originalX: (i % gridSize) * pieceWidth,        // X yang dipecahkan di area puzzle utama
                    originalY: Math.floor(i / gridSize) * pieceHeight, // Y yang dipecahkan di area puzzle utama
                    currentX: (i % gridSize) * pieceWidth,         // X saat ini awal (posisi terpecahkan)
                    currentY: Math.floor(i / gridSize) * pieceHeight, // Y saat ini awal (posisi terpecahkan)
                    isLocked: true,                               // Awalnya terkunci (keadaan terpecahkan)
                    inTray: false,                                // Awalnya tidak di nampan
                    cachedCanvas: cachedPieceCanvas               // Simpan potongan yang sudah di-render
                });
            }
            moves = 0;
            updateMoveCounter();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            puzzleReady = true; // Atur ke true hanya jika potongan berhasil dibuat
            drawPuzzle(); // Gambar dalam keadaan terpecahkan pada awalnya
            console.log('Puzzle diinisialisasi. Jumlah potongan:', puzzlePieces.length);
        }

        // =====================================================================
        // Menggambar Puzzle di Kanvas (area utama dan nampan)
        // =====================================================================
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);

            if (!puzzleReady) {
                ctx.fillStyle = '#6366f1'; // Warna indigo
                ctx.font = `2rem Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    'Unggah atau Pilih Gambar',
                    puzzleCanvas.width / 2,
                    puzzleCanvas.height / 2
                );
                return; // Berhenti menggambar lebih lanjut jika puzzle belum siap
            }

            // 1. Gambar latar belakang untuk area puzzle utama dan labelnya
            ctx.fillStyle = '#f3f4f6'; // Abu-abu terang untuk area utama
            ctx.fillRect(0, 0, mainPuzzleAreaDimension, mainPuzzleAreaDimension);
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, mainPuzzleAreaDimension, mainPuzzleAreaDimension);

            // "Susun di Sini" label - only if no pieces are locked in place
            const anyPieceLockedInAssembly = puzzlePieces.some(p => p.isLocked && !p.inTray);
            if (!anyPieceLockedInAssembly) { // Tampilkan hanya saat area perakitan kosong dari potongan yang terkunci
                ctx.fillStyle = ASSEMBLE_LABEL_COLOR; // Warna yang lebih lembut untuk label
                ctx.font = `2rem Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    'Susun di Sini',
                    mainPuzzleAreaDimension / 2,
                    mainPuzzleAreaDimension / 2
                );
            }

            // 2. Gambar latar belakang untuk area nampan dan labelnya
            ctx.fillStyle = '#e0e7ff'; // Indigo terang untuk nampan
            ctx.fillRect(0, trayAreaStartY, puzzleCanvas.width, trayAreaTotalHeight);
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, trayAreaStartY, puzzleCanvas.width, trayAreaTotalHeight);
            
            ctx.fillStyle = '#312e81';
            ctx.font = `1.2rem Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                'Nampan Potongan',
                puzzleCanvas.width / 2,
                trayAreaStartY + TRAY_LABEL_OFFSET_Y
            );

            // Urutkan potongan untuk urutan penggambaran: terkunci dulu, lalu tidak terkunci, lalu yang diseret (di atas)
            const sortedPieces = [...puzzlePieces].sort((a, b) => {
                if (a.isLocked && !b.isLocked) return -1;
                if (!a.isLocked && b.isLocked) return 1;
                // Untuk potongan yang tidak terkunci, pastikan draggedPiece adalah yang terakhir
                if (a === draggedPiece) return 1;
                if (b === draggedPiece) return -1;
                return 0;
            });

            sortedPieces.forEach(piece => {
                if (piece === draggedPiece) return; // Lewati penggambaran potongan yang diseret di sini, akan digambar terakhir

                ctx.drawImage(piece.cachedCanvas, piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                
                // Terapkan batas berdasarkan status
                if (piece.isLocked) {
                    ctx.strokeStyle = LOCKED_PIECE_BORDER_COLOR; // Batas hitam
                    ctx.lineWidth = 3;
                    ctx.shadowColor = LOCKED_PIECE_SHADOW_COLOR; // Cahaya hitam
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                    ctx.shadowColor = 'transparent'; // Atur ulang bayangan
                    ctx.shadowBlur = 0;
                } else if (piece.inTray) {
                    ctx.strokeStyle = '#6b7280'; // Abu-abu untuk potongan di nampan
                    ctx.lineWidth = 1; // Batas lebih tipis untuk potongan nampan
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                } else {
                    ctx.strokeStyle = '#6366f1'; // Biru default untuk potongan yang dapat dipindahkan di area utama
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                }
            });

            // Gambar potongan yang diseret terakhir untuk memastikan selalu di atas
            if (draggedPiece) {
                ctx.drawImage(draggedPiece.cachedCanvas, draggedPiece.currentX, draggedPiece.currentY, pieceWidth, pieceHeight);
                ctx.strokeStyle = '#ef4444'; // Batas merah untuk potongan yang diseret
                ctx.lineWidth = 3;
                ctx.strokeRect(draggedPiece.currentX, draggedPiece.currentY, pieceWidth, pieceHeight);
            }
        }

        // =====================================================================
        // Acak Puzzle (menempatkan potongan ke dalam nampan)
        // =====================================================================
        shuffleButton.addEventListener('click', shufflePuzzle);

        function shufflePuzzle() {
            if (!puzzleReady) {
                showMessageBox("Silakan unggah gambar terlebih dahulu.");
                return;
            }
            console.log('Mengacak puzzle...');

            const totalPieces = gridSize * gridSize;
            const availableTrayWidth = puzzleCanvas.width - (2 * TRAY_PADDING);
            const pieceSide = pieceWidth; // Asumsikan pieceWidth == pieceHeight

            const maxPiecesPerRow = Math.floor(availableTrayWidth / pieceSide);
            const actualPiecesPerRow = Math.max(1, maxPiecesPerRow); // Pastikan setidaknya 1 potongan per baris

            const numRowsForPieces = Math.ceil(totalPieces / actualPiecesPerRow);

            const startYForPiecesInTray = trayAreaStartY + TRAY_LABEL_OFFSET_Y + TRAY_PADDING;
            
            const shuffledPositions = [];
            for (let i = 0; i < totalPieces; i++) {
                const rowInTray = Math.floor(i / actualPiecesPerRow);
                const colInTray = i % actualPiecesPerRow;

                // Hitung posisi X, pusatkan potongan di dalam sel grid potensialnya
                const x = (colInTray * pieceSide) + (availableTrayWidth - (actualPiecesPerRow * pieceSide)) / 2 + TRAY_PADDING;
                const y = startYForPiecesInTray + (rowInTray * pieceSide);
                shuffledPositions.push({ x, y });
            }
            // Acak posisi itu sendiri
            for (let i = shuffledPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledPositions[i], shuffledPositions[j]] = [shuffledPositions[j], shuffledPositions[i]];
            }

            puzzlePieces.forEach((piece, index) => {
                piece.currentX = shuffledPositions[index].x;
                piece.currentY = shuffledPositions[index].y;
                piece.isLocked = false;    // Buka kunci semua potongan
                piece.inTray = true;       // Tandai sebagai di nampan
            });

            moves = 0;
            updateMoveCounter();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            drawPuzzle();
            console.log('Puzzle diacak dan potongan dipindahkan ke nampan.');
        }

        // =====================================================================
        // Atur Ulang Puzzle ke Urutan Asli (menempatkan semua potongan di area perakitan utama)
        // =====================================================================
        resetButton.addEventListener('click', () => {
            if (!puzzleReady) {
                showMessageBox("Silakan unggah gambar terlebih dahulu.");
                return;
            }
            console.log('Mengatur ulang puzzle...');

            puzzlePieces.forEach(piece => {
                piece.currentX = piece.originalX;
                piece.currentY = piece.originalY;
                piece.isLocked = true;    // Kunci potongan dalam keadaan terpecahkan
                piece.inTray = false;     // Tidak di nampan
            });

            moves = 0;
            updateMoveCounter();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            drawPuzzle();
            checkWin(); // Periksa segera apakah reset membuatnya terpecahkan
            console.log('Puzzle diatur ulang ke keadaan terpecahkan.');
        });

        // =====================================================================
        // Penanganan Seret dan Lepas
        // =====================================================================
        puzzleCanvas.addEventListener('mousedown', handleMouseDown);
        puzzleCanvas.addEventListener('touchstart', handleMouseDown, { passive: false });

        function handleMouseDown(event) {
            console.log('handleMouseDown triggered.');
            if (!puzzleReady) {
                console.log('Puzzle not ready, blocking mouse down.');
                return;
            }
            event.preventDefault(); // Mencegah pengguliran pada sentuhan

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            let clientX = event.clientX;
            let clientY = event.clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }

            const mouseX = (clientX - rect.left) * scaleX;
            const mouseY = (clientY - rect.top) * scaleY;

            console.log(`Mouse Down at: (${mouseX}, ${mouseY})`);

            // Cari potongan paling atas di lokasi yang diklik yang TIDAK terkunci
            for (let i = puzzlePieces.length - 1; i >= 0; i--) {
                const piece = puzzlePieces[i];
                if (!piece.isLocked &&
                    mouseX >= piece.currentX && mouseX <= piece.currentX + pieceWidth &&
                    mouseY >= piece.currentY && mouseY <= piece.currentY + pieceHeight) {
                    
                    draggedPiece = piece;
                    offsetX = mouseX - piece.currentX;
                    offsetY = mouseY - piece.currentY;

                    draggedPiece.inTray = false; // Tandai sebagai tidak lagi di nampan setelah diseret

                    // Bawa potongan yang diseret ke bagian atas urutan gambar
                    puzzlePieces.splice(i, 1);
                    puzzlePieces.push(draggedPiece);

                    drawPuzzle(); // Gambar ulang untuk menunjukkan potongan yang diseret di atas
                    
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    document.addEventListener('touchmove', handleMouseMove, { passive: false });
                    document.addEventListener('touchend', handleMouseUp);
                    console.log(`Dragging piece ID: ${draggedPiece.id}`);
                    return;
                }
            }
            console.log('No movable piece found at click location.');
        }

        function handleMouseMove(event) {
            if (!draggedPiece) return;
            event.preventDefault(); // Mencegah pengguliran saat menyeret

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            let clientX = event.clientX;
            let clientY = event.clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }

            let newX = (clientX - rect.left) * scaleX - offsetX;
            let newY = (clientY - rect.top) * scaleY - offsetY;

            // Jepit newX dan newY dalam batas kanvas
            newX = Math.max(0, Math.min(newX, puzzleCanvas.width - pieceWidth));
            newY = Math.max(0, Math.min(newY, puzzleCanvas.height - pieceHeight));

            draggedPiece.currentX = newX;
            draggedPiece.currentY = newY;
            drawPuzzle();
            // console.log(`Dragging piece ${draggedPiece.id} to: (${newX}, ${newY})`); // Hati-hati, ini bisa menghasilkan banyak log
        }

        function handleMouseUp() {
            console.log('handleMouseUp triggered.');
            if (!draggedPiece) return;

            // Dapatkan titik tengah potongan saat dijatuhkan
            const pieceCenterX = draggedPiece.currentX + pieceWidth / 2;
            const pieceCenterY = draggedPiece.currentY + pieceHeight / 2;

            // Periksa apakah dijatuhkan di dalam area puzzle utama
            const isDroppedInMainArea = pieceCenterX >= 0 && pieceCenterX <= mainPuzzleAreaDimension &&
                                         pieceCenterY >= 0 && pieceCenterY <= mainPuzzleAreaDimension;

            let snapped = false;

            if (isDroppedInMainArea) {
                // Hitung posisi relatif terhadap kiri atas kanvas
                const targetXForSnap = draggedPiece.originalX;
                const targetYForSnap = draggedPiece.originalY;

                // Periksa apakah potongan yang diseret dekat dengan posisi aslinya
                const dx = draggedPiece.currentX - targetXForSnap;
                const dy = draggedPiece.currentY - targetYForSnap;

                if (Math.abs(dx) < snapThreshold && Math.abs(dy) < snapThreshold) {
                    // Periksa apakah ada potongan lain yang terkunci sudah menempati titik yang sama persis ini
                    const occupyingPiece = puzzlePieces.find(p => 
                        p !== draggedPiece && p.isLocked &&
                        p.currentX === targetXForSnap && p.currentY === targetYForSnap
                    );

                    if (!occupyingPiece) {
                        draggedPiece.currentX = targetXForSnap;
                        draggedPiece.currentY = targetYForSnap;
                        draggedPiece.isLocked = true; // Kunci potongan pada tempatnya
                        draggedPiece.inTray = false; // Pastikan tidak ditandai sebagai di nampan
                        snapped = true;
                        console.log(`Potongan ${draggedPiece.id} terkunci pada posisi yang benar.`);
                    } else {
                        console.log(`Posisi ${draggedPiece.id} benar tapi sudah ditempati oleh potongan terkunci ${occupyingPiece.id}.`);
                    }
                }
                // Jika dijatuhkan di area utama TAPI TIDAK terkunci, potongan tetap di posisi saat ini (diseret).
                // Sudah diperbarui oleh handleMouseMove, jadi tidak perlu perubahan furtherX/Y di sini.
                // Pastikan saja status terkunci/di nampan-nya benar.
                if (!snapped) {
                    draggedPiece.isLocked = false;
                    draggedPiece.inTray = false; // Tidak lagi di nampan jika di area utama
                    console.log(`Potongan ${draggedPiece.id} dijatuhkan di area utama, tidak terkunci.`);
                }

            } else { // Dijatuhkan di luar area puzzle utama (misalnya, di nampan, atau sepenuhnya di luar kanvas)
                // Jika dijatuhkan di area nampan, tetap di posisi saat ini (diseret).
                // handleMouseMove sudah menjepitnya, jadi cukup perbarui flag.
                // Jika dijatuhkan di luar area nampan, juga biarkan di posisi terjepitnya.
                draggedPiece.inTray = true; // Anggap di nampan jika tidak terkunci di area utama
                draggedPiece.isLocked = false; 
                console.log(`Potongan ${draggedPiece.id} kembali ke nampan/tetap di posisi terjepit di luar area utama.`);
            }
            
            draggedPiece = null;
            drawPuzzle(); // Gambar ulang terakhir
            checkWin(); // Periksa kemenangan setelah potongan dijatuhkan
            moves++;
            updateMoveCounter();

            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.removeEventListener('touchmove', handleMouseMove);
            document.removeEventListener('touchend', handleMouseUp);
        }

        // =====================================================================
        // Perbarui Penghitung Gerakan
        // =====================================================================
        function updateMoveCounter() {
            moveCounterDisplay.textContent = moves;
        }

        // =====================================================================
        // Periksa Kondisi Menang
        // =====================================================================
        function checkWin() {
            let solved = true;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                // Potongan "benar" jika terkunci DAN posisi saat ini cocok dengan posisi aslinya
                if (!piece.isLocked || piece.currentX !== piece.originalX || piece.currentY !== piece.originalY) {
                    solved = false;
                    break;
                }
            }

            if (solved) {
                puzzleCanvas.classList.add('puzzle-solved-animation');
                showMessageBox(`Selamat! Puzzle telah selesai dalam ${moves} gerakan!`);
                console.log('Puzzle terpecahkan!');
            }
        }

        // =====================================================================
        // Penanganan Responsivitas Ukuran Jendela
        // =====================================================================
        window.addEventListener('resize', () => {
            console.log('Ukuran jendela diubah. Menghitung ulang posisi...');
            const oldCanvasWidth = puzzleCanvas.width;
            const oldCanvasHeight = puzzleCanvas.height;

            const wasPuzzleReady = puzzleReady;
            const wasShuffled = puzzlePieces.some(p => !p.isLocked); 

            // Simpan status dan posisi relatif potongan yang tidak terkunci
            // sebelum inisialisasi ulang
            const savedPieceStates = puzzlePieces.map(p => ({
                id: p.id,
                currentX: p.currentX,
                currentY: p.currentY,
                isLocked: p.isLocked,
                inTray: p.inTray
            }));
            
            // Re-calculate dimensions and update canvas size
            const container = puzzleCanvas.parentElement;
            const newMaxCanvasWidth = Math.max(300, Math.min(container.clientWidth, window.innerHeight * 0.75));
            mainPuzzleAreaDimension = newMaxCanvasWidth;
            pieceWidth = mainPuzzleAreaDimension / gridSize;
            pieceHeight = mainPuzzleAreaDimension / gridSize;

            const totalPieces = gridSize * gridSize;
            const piecesPerRowInTray = Math.floor((mainPuzzleAreaDimension - (2 * TRAY_PADDING)) / pieceWidth);
            const effectivePiecesPerRow = Math.max(1, piecesPerRowInTray);
            const requiredTrayRows = Math.ceil(totalPieces / effectivePiecesPerRow);
            trayAreaTotalHeight = (requiredTrayRows * pieceHeight) + (2 * TRAY_PADDING) + TRAY_LABEL_OFFSET_Y + TRAY_PADDING;
            trayAreaTotalHeight = Math.max(trayAreaTotalHeight, pieceHeight + (2 * TRAY_PADDING) + TRAY_LABEL_OFFSET_Y + TRAY_PADDING);
            trayAreaStartY = mainPuzzleAreaDimension + VERTICAL_SPACING_BETWEEN_AREAS;

            puzzleCanvas.width = mainPuzzleAreaDimension;
            puzzleCanvas.height = mainPuzzleAreaDimension + VERTICAL_SPACING_BETWEEN_AREAS + trayAreaTotalHeight;
            
            // Perbarui dimensi kanvas cache potongan dan posisinya
            puzzlePieces.forEach(piece => {
                // Perbarui posisi asli yang diskalakan
                piece.originalX = (piece.id % gridSize) * pieceWidth;
                piece.originalY = Math.floor(piece.id / gridSize) * pieceHeight;

                // Temukan status yang disimpan untuk potongan ini
                const oldPieceData = savedPieceStates.find(s => s.id === piece.id);
                if (oldPieceData) {
                    piece.isLocked = oldPieceData.isLocked;
                    piece.inTray = oldPieceData.inTray;

                    if (piece.isLocked) {
                        // Jika terkunci, paksakan ke posisi asli yang benar yang baru diskalakan
                        piece.currentX = piece.originalX;
                        piece.currentY = piece.originalY;
                        piece.inTray = false; // Potongan terkunci tidak di nampan
                    } else {
                        // Jika tidak terkunci, skalakan posisi saat ini dan jepit
                        let newX = oldPieceData.currentX;
                        let newY = oldPieceData.currentY;
                        
                        if (oldCanvasWidth > 0 && oldCanvasHeight > 0) {
                            newX = (oldPieceData.currentX / oldCanvasWidth) * puzzleCanvas.width;
                            newY = (oldPieceData.currentY / oldCanvasHeight) * puzzleCanvas.height;
                        }

                        // Jepit newX dan newY dalam batas kanvas yang baru
                        piece.currentX = Math.max(0, Math.min(newX, puzzleCanvas.width - pieceWidth));
                        piece.currentY = Math.max(0, Math.min(newY, puzzleCanvas.height - pieceHeight));
                    }
                }

                // Render ulang kanvas cache dengan dimensi potongan baru
                const pieceCtx = piece.cachedCanvas.getContext('2d');
                piece.cachedCanvas.width = pieceWidth;
                piece.cachedCanvas.height = pieceHeight;
                let sourceSize = Math.min(originalImage.naturalWidth, originalImage.naturalHeight);
                let offsetXImage = (originalImage.naturalWidth - sourceSize) / 2;
                let offsetYImage = (originalImage.naturalHeight - sourceSize) / 2;
                pieceCtx.clearRect(0, 0, pieceWidth, pieceHeight);
                pieceCtx.drawImage(
                    originalImage,
                    offsetXImage + (sourceSize / gridSize) * (piece.id % gridSize),
                    offsetYImage + (sourceSize / gridSize) * Math.floor(piece.id / gridSize),
                    sourceSize / gridSize,
                    sourceSize / gridSize,
                    0, 0,
                    pieceWidth, pieceHeight
                );
            });
            
            // Gambar ulang seluruh puzzle setelah posisi diperbarui
            drawPuzzle();
            console.log('Posisi dihitung ulang dan digambar ulang.');
        });

        // =====================================================================
        // Fungsi Penyimpanan dan Pemuatan Preferensi (LocalStorage)
        // =====================================================================
        function loadPreferences() {
            const savedGridSize = localStorage.getItem('jigsawGridSize');
            if (savedGridSize) {
                gridSizeSelect.value = savedGridSize;
                gridSize = parseInt(savedGridSize);
                console.log('Preferensi ukuran grid dimuat:', gridSize);
            }
        }

        // =====================================================================
        // Penanganan Tombol "Lihat Gambar Asli"
        // =====================================================================
        viewOriginalImageButton.addEventListener('click', () => {
            if (originalImage.src && originalImage.complete && originalImage.naturalWidth > 0) { // Pastikan gambar dimuat sebelum ditampilkan
                fullImageDisplay.src = originalImage.src;
                mainContent.classList.add('main-content-hidden'); // Sembunyikan UI puzzle utama
                originalImageDisplayContainer.classList.add('show'); // Tampilkan container gambar asli
                originalImageDisplayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                console.log('Menampilkan gambar asli.');
            } else {
                showMessageBox("Tidak ada gambar yang dimuat untuk ditampilkan.");
                console.warn('Mencoba melihat gambar asli, tetapi tidak ada gambar yang dimuat.');
            }
        });

        backToPuzzleButton.addEventListener('click', () => {
            originalImageDisplayContainer.classList.remove('show'); // Sembunyikan container gambar asli
            mainContent.classList.remove('main-content-hidden'); // Tampilkan UI puzzle utama
            puzzleCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Gulir ke puzzle
            console.log('Kembali ke tampilan puzzle.');
        });

        // =====================================================================
        // Pengaturan Pemuatan Halaman Awal (gambar placeholder)
        // =====================================================================
        window.onload = () => {
            loadPreferences(); // Muat preferensi tersimpan terlebih dahulu
            console.log('Jendela dimuat. Menginisialisasi dengan placeholder...');
            
            // Atur ukuran kanvas awal di sini untuk memastikan terlihat bahkan sebelum gambar dimuat
            const initialCanvasWidth = Math.max(300, Math.min(puzzleCanvas.parentElement.clientWidth, window.innerHeight * 0.75));
            mainPuzzleAreaDimension = initialCanvasWidth; // Gunakan ini untuk perhitungan awal
            pieceWidth = initialCanvasWidth / gridSize; // Hitung pieceWidth awal
            pieceHeight = initialCanvasWidth / gridSize;

            // Perkirakan tinggi nampan awal untuk penggambaran placeholder
            const totalPiecesEstimate = gridSize * gridSize;
            const piecesPerRowEstimate = Math.floor((initialCanvasWidth - (2 * TRAY_PADDING)) / pieceWidth);
            const effectivePiecesPerRowEstimate = Math.max(1, piecesPerRowEstimate);
            const requiredTrayRowsEstimate = Math.ceil(totalPiecesEstimate / effectivePiecesPerRowEstimate);
            trayAreaTotalHeight = (requiredTrayRowsEstimate * pieceHeight) + (2 * TRAY_PADDING) + TRAY_LABEL_OFFSET_Y + TRAY_PADDING;
            trayAreaStartY = initialCanvasWidth + VERTICAL_SPACING_BETWEEN_AREAS;

            puzzleCanvas.width = initialCanvasWidth;
            puzzleCanvas.height = initialCanvasWidth + VERTICAL_SPACING_BETWEEN_AREAS + trayAreaTotalHeight;
            
            originalImage.onload = () => {
                console.log('Gambar placeholder awal dimuat. Menginisialisasi komponen puzzle.');
                initializePuzzle();
                // Jika inisialisasi berhasil dengan placeholder, acak
                if (puzzleReady) { 
                    shufflePuzzle(); 
                }
            };
            originalImage.onerror = () => {
                console.error('Gagal memuat gambar placeholder awal.');
                showMessageBox("Gagal memuat gambar placeholder awal. Harap periksa koneksi internet Anda.");
                puzzleReady = false;
                drawPuzzle(); // Gambar teks 'Unggah atau Pilih Gambar'
            };
            const placeholderSize = 600; 
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`; 
            drawPuzzle(); // Penggambaran awal untuk segera menunjukkan teks placeholder
        };
    </script>
</body>
</html>

