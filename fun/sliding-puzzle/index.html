<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Interaktif</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* Latar belakang gradient modern */
            background-image: linear-gradient(to bottom right, #a78bfa, #818cf8, #6366f1); /* Ungu-biru gradient */
            background-attachment: fixed; /* Memastikan gradient tetap saat scroll */
            overflow-x: hidden; /* Mencegah overflow horizontal */
        }
        /* Styling untuk canvas */
        canvas {
            display: block; /* Menghilangkan spasi ekstra di bawah canvas */
            background-color: #ffffff; /* Latar belakang canvas putih bersih */
            border: 3px solid #4f46e5; /* Border ungu tua (indigo-600) */
            border-radius: 0.75rem; /* Sudut membulat */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: none; /* Mencegah gulir saat menyeret pada sentuhan */
            user-select: none; /* Non-seleksi teks */
            transition: transform 0.5s ease-out, border 0.5s ease-out, box-shadow 0.5s ease-out;
        }
        /* Styling untuk tombol */
        .btn-primary-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6);
            transition: background-image 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed);
        }
        .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #3730a3, #5b21b6);
            transform: scale(0.98);
        }
        .btn-gray {
            background-color: #6b7280;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-gray:hover {
            background-color: #4b5563;
        }
        .btn-gray:active {
            background-color: #374151;
            transform: scale(0.98);
        }
        /* Styling untuk gambar contoh */
        .sample-image-container {
            width: 80px;
            height: 80px;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .sample-image-container:hover {
            transform: scale(1.05);
            border-color: #6366f1;
        }
        .sample-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        /* Animasi saat puzzle selesai */
        .puzzle-solved-animation {
            animation: puzzle-bounce 0.5s ease-out forwards;
            border-color: #10b981;
            box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.7), 0 0 30px 10px rgba(16, 185, 129, 0.5);
        }
        @keyframes puzzle-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        /* Styling untuk kotak pesan modal */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            border: 2px solid #4f46e5;
        }
        /* Overlay gelap di belakang modal */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        /* Styling untuk tampilan gambar asli */
        .original-image-display-container {
            display: none; /* Sembunyikan secara default */
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 3xl; /* Batasi lebar maksimum */
        }
        .original-image-display-container.show {
            display: flex; /* Tampilkan saat class 'show' ditambahkan */
        }
        .original-image-display-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        .original-image-display-container button {
            margin-top: 0; /* Override margin-top default jika ada */
        }
        /* Menyembunyikan konten utama saat gambar asli ditampilkan */
        .main-content-hidden {
            display: none;
        }
    </style>
</head>
<body class="text-gray-900">

    <div id="mainContent" class="w-full max-w-3xl bg-white p-6 rounded-xl shadow-lg my-4">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-6">Sliding Puzzle Interaktif</h1>

        <!-- Bagian Unggah Foto -->
        <div class="mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-gray-700 mb-2">Unggah Foto Anda:</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
        </div>

        <!-- Bagian Pilih Gambar Contoh -->
        <div class="mb-6 text-center">
            <label class="block text-lg font-medium text-gray-700 mb-2">Atau Pilih Gambar Contoh:</label>
            <div id="sampleImageContainer" class="flex flex-wrap justify-center gap-2">
                <!-- Gambar contoh baru ditambahkan di sini -->
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/1.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/refs/heads/main/fun/sliding-puzzle/gambar/1.jpg" alt="Contoh Gambar 1">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/2.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/2.jpg" alt="Contoh Gambar 2">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/3.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/3.jpg" alt="Contoh Gambar 3">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/4.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/4.jpg" alt="Contoh Gambar 4">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.png" alt="Contoh Gambar 5">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.jpg" alt="Contoh Gambar 6">
                </div>
            </div>
        </div>

        <!-- Pilihan Ukuran Grid -->
        <div class="mb-6 text-center">
            <label for="gridSizeSelect" class="block text-lg font-medium text-gray-700 mb-2">Pilih Ukuran Puzzle:</label>
            <select id="gridSizeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                <option value="3" selected>3x3</option>
                <option value="4">4x4</option>
                <option value="5">5x5</option>
                <option value="6">6x6</option>
                <option value="8">8x8</option>
            </select>
        </div>
        
        <!-- Statistik Permainan -->
        <div class="flex justify-center gap-8 mb-4 text-center">
            <div class="text-lg font-semibold text-gray-700">
                Waktu: <span id="timerDisplay" class="text-indigo-700">00:00</span>
            </div>
            <div class="text-lg font-semibold text-gray-700">
                Langkah: <span id="movesDisplay" class="text-indigo-700">0</span>
            </div>
            <div class="text-lg font-semibold text-gray-700">
                Status: <span id="solveStatusDisplay" class="text-indigo-700">Siap</span>
            </div>
            <!-- Elemen baru untuk menampilkan Mode (Angka/Tanpa Nomer) -->
            <div class="text-lg font-semibold text-gray-700">
                Mode: <span id="modeDisplay" class="text-indigo-700"></span>
            </div>
        </div>

        <!-- Tombol Aksi -->
        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="shuffleButton" class="btn-primary-gradient text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Acak
            </button>
            <button id="solveButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Selesaikan
            </button>
            <button id="resetButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Reset
            </button>
            <!-- Tombol untuk mengubah mode angka/gambar -->
            <button id="toggleNumbersButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Tampilkan/Sembunyikan Angka
            </button>
        </div>

        <!-- Kanvas untuk Puzzle -->
        <div class="relative w-full flex justify-center">
            <canvas id="puzzleCanvas" class="w-full h-auto max-w-full"></canvas>
        </div>
        
        <!-- Tombol Lihat Gambar Asli -->
        <div class="text-center mt-4">
            <button id="viewOriginalImageButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Lihat Gambar Asli
            </button>
        </div>
    </div>

    <!-- Message Box untuk Notifikasi -->
    <div id="messageBoxContainer"></div>

    <!-- Container untuk tampilan gambar asli -->
    <div id="originalImageDisplayContainer" class="original-image-display-container">
        <img id="fullImageDisplay" src="" alt="Gambar Asli">
        <button id="backToPuzzleButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md">
            Kembali ke Puzzle
        </button>
    </div>

    <script>
        // Mendapatkan elemen DOM
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSelect = document.getElementById('gridSizeSelect');
        const shuffleButton = document.getElementById('shuffleButton');
        const solveButton = document.getElementById('solveButton');
        const resetButton = document.getElementById('resetButton');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const ctx = puzzleCanvas.getContext('2d');
        const timerDisplay = document.getElementById('timerDisplay');
        const movesDisplay = document.getElementById('movesDisplay');
        const solveStatusDisplay = document.getElementById('solveStatusDisplay');
        const messageBoxContainer = document.getElementById('messageBoxContainer');
        const toggleNumbersButton = document.getElementById('toggleNumbersButton'); // New button
        const modeDisplay = document.getElementById('modeDisplay'); // New element
        const viewOriginalImageButton = document.getElementById('viewOriginalImageButton');
        const originalImageDisplayContainer = document.getElementById('originalImageDisplayContainer');
        const fullImageDisplay = document.getElementById('fullImageDisplay');
        const backToPuzzleButton = document.getElementById('backToPuzzleButton');
        const mainContent = document.getElementById('mainContent');

        const sampleImageContainers = document.querySelectorAll('.sample-image-container');

        // Variabel global untuk game state
        let originalImage = new Image();
        let gridSize = parseInt(gridSizeSelect.value);
        let puzzlePieces = [];
        let emptyPieceIndex; // Indeks potongan kosong
        let pieceSize; // Ukuran sisi potongan puzzle
        let moves = 0;
        let timerInterval;
        let seconds = 0;
        let puzzleReady = false;
        let isShuffled = false;
        let solving = false; // Status apakah AI sedang menyelesaikan
        let shuffling = false; // Status apakah sedang dalam proses pengacakan
        let isProcessingClick = false; // Mencegah klik ganda saat animasi berjalan
        let showNumbers = true; // Kontrol apakah angka ditampilkan atau tidak
        let enableAutoSolve = false; // Untuk mengizinkan penyelesaian otomatis dari luar

        // =====================================================================
        // Fungsi Utilitas untuk Notifikasi (Pengganti alert())
        // =====================================================================
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p class="text-xl font-semibold mb-4">${message}</p>
                <button id="closeMessageBox" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300">Oke</button>
            `;
            
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            messageBoxContainer.appendChild(overlay);
            messageBoxContainer.appendChild(messageBox);

            document.getElementById('closeMessageBox').onclick = () => {
                messageBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Fungsi untuk memperbarui tampilan waktu
        // =====================================================================
        function updateTimer() {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        // =====================================================================
        // Fungsi untuk memulai timer
        // =====================================================================
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
        }

        // =====================================================================
        // Fungsi untuk menghentikan timer
        // =====================================================================
        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // =====================================================================
        // Fungsi untuk memperbarui tampilan langkah
        // =====================================================================
        function updateMovesDisplay() {
            movesDisplay.textContent = moves;
        }

        // =====================================================================
        // Fungsi untuk memperbarui tampilan status solusi
        // =====================================================================
        function updateSolveStatusDisplay(status) {
            solveStatusDisplay.textContent = status;
        }

        // =====================================================================
        // Fungsi untuk memperbarui tampilan Mode (Angka/Tanpa Nomer)
        // =====================================================================
        function updateModeDisplay() {
            if (showNumbers) {
                modeDisplay.textContent = 'Angka';
            } else {
                modeDisplay.textContent = 'Tanpa Nomer'; // "Tanpa Nomer" mode
            }
        }

        // =====================================================================
        // Inisialisasi Puzzle: memotong gambar menjadi potongan
        // =====================================================================
        function initializePuzzle() {
            console.log('Initializing puzzle with grid size:', gridSize);
            const minDim = Math.min(originalImage.naturalWidth, originalImage.naturalHeight);
            pieceSize = minDim / gridSize;

            // Atur ukuran kanvas sesuai dengan gambar yang dimuat dan ukuran grid
            puzzleCanvas.width = gridSize * pieceSize;
            puzzleCanvas.height = gridSize * pieceSize;

            puzzlePieces = [];
            for (let i = 0; i < gridSize * gridSize; i++) {
                puzzlePieces.push({
                    id: i,
                    originalX: (i % gridSize) * pieceSize,
                    originalY: Math.floor(i / gridSize) * pieceSize,
                    currentX: (i % gridSize) * pieceSize,
                    currentY: Math.floor(i / gridSize) * pieceSize
                });
            }
            emptyPieceIndex = gridSize * gridSize - 1; // Potongan terakhir adalah yang kosong
            puzzlePieces[emptyPieceIndex].isEmpty = true; // Tandai potongan kosong
            puzzleReady = true;
            moves = 0;
            seconds = 0;
            updateMovesDisplay();
            updateTimer();
            updateSolveStatusDisplay('Siap');
            updateModeDisplay(); // Perbarui tampilan mode
            drawPuzzle();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            enableAllButtons(); // Pastikan tombol diaktifkan setelah inisialisasi
        }

        // =====================================================================
        // Menggambar Puzzle di Kanvas
        // =====================================================================
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height); // Bersihkan seluruh kanvas

            // Gambar setiap potongan puzzle
            puzzlePieces.forEach(piece => {
                if (piece.isEmpty) {
                    // Gambar kotak kosong untuk potongan kosong
                    ctx.fillStyle = '#f3f4f6'; // Warna abu-abu terang
                    ctx.fillRect(piece.currentX, piece.currentY, pieceSize, pieceSize);
                    // Gambar batas untuk kotak kosong
                    ctx.strokeStyle = '#d1d5db'; // Warna abu-abu yang sedikit lebih gelap
                    ctx.lineWidth = 1;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceSize, pieceSize);
                } else {
                    // Gambar bagian gambar asli
                    ctx.drawImage(
                        originalImage,
                        piece.originalX, piece.originalY, pieceSize, pieceSize, // Sumber di gambar asli
                        piece.currentX, piece.currentY, pieceSize, pieceSize    // Tujuan di kanvas puzzle
                    );
                    // Gambar batas di sekitar setiap potongan
                    ctx.strokeStyle = '#9ca3af'; // Abu-abu sedang
                    ctx.lineWidth = 1;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceSize, pieceSize);

                    // Gambar nomor di tengah potongan jika showNumbers true
                    if (showNumbers) {
                        ctx.fillStyle = '#1f2937'; // Abu-abu gelap untuk angka
                        ctx.font = `${pieceSize * 0.4}px 'Inter', sans-serif`; // Sesuaikan ukuran font secara dinamis
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(piece.id + 1, piece.currentX + pieceSize / 2, piece.currentY + pieceSize / 2);
                    }
                }
            });
        }

        // =====================================================================
        // Mendapatkan posisi mouse/sentuhan relatif terhadap kanvas
        // =====================================================================
        function getEventCoords(event) {
            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            let clientX = event.clientX;
            let clientY = event.clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            return { x, y };
        }

        // =====================================================================
        // Penanganan Klik Puzzle (untuk gerakan)
        // =====================================================================
        puzzleCanvas.addEventListener('click', handlePuzzleClick);
        puzzleCanvas.addEventListener('touchend', handlePuzzleClick);

        function handlePuzzleClick(event) {
            if (!puzzleReady || solving || shuffling || isProcessingClick) return; // Abaikan klik jika tidak siap atau sedang memproses

            const { x, y } = getEventCoords(event);
            const clickedCol = Math.floor(x / pieceSize);
            const clickedRow = Math.floor(y / pieceSize);
            const clickedIndex = clickedRow * gridSize + clickedCol;

            // Pastikan indeks yang diklik valid dan bukan potongan kosong
            if (clickedIndex < 0 || clickedIndex >= puzzlePieces.length || puzzlePieces[clickedIndex].isEmpty) {
                return;
            }

            const clickedPiece = puzzlePieces[clickedIndex];
            const emptyPiece = puzzlePieces[emptyPieceIndex];

            // Periksa apakah potongan yang diklik dapat digeser ke ruang kosong
            const canMove = (Math.abs(clickedPiece.currentX - emptyPiece.currentX) < 1 && Math.abs(clickedPiece.currentY - emptyPiece.currentY) === pieceSize) ||
                            (Math.abs(clickedPiece.currentY - emptyPiece.currentY) < 1 && Math.abs(clickedPiece.currentX - emptyPiece.currentX) === pieceSize);

            if (canMove) {
                isProcessingClick = true; // Set flag untuk mencegah klik ganda
                if (!timerInterval) startTimer(); // Mulai timer pada gerakan pertama
                
                // Tukar posisi potongan secara logis
                const tempX = clickedPiece.currentX;
                const tempY = clickedPiece.currentY;

                clickedPiece.currentX = emptyPiece.currentX;
                clickedPiece.currentY = emptyPiece.currentY;
                emptyPiece.currentX = tempX;
                emptyPiece.currentY = tempY;

                // Perbarui indeks potongan kosong
                emptyPieceIndex = clickedIndex;

                moves++;
                updateMovesDisplay();

                // Animasi gerakan
                // Untuk kesederhanaan, kita bisa langsung menggambar ulang atau menambahkan animasi Tween/requestAnimationFrame
                drawPuzzle(); 
                isProcessingClick = false; // Reset flag setelah gerakan selesai

                // Periksa apakah puzzle sudah selesai
                checkWin();
            }
        }

        // =====================================================================
        // Fungsi untuk mengacak puzzle
        // =====================================================================
        shuffleButton.addEventListener('click', async () => {
            if (!puzzleReady || solving || shuffling) return;

            solving = false;
            shuffling = true;
            isProcessingClick = false;
            updateSolveStatusDisplay('Mengacak...');
            stopTimer(); // Hentikan timer saat mengacak
            seconds = 0; // Reset waktu
            updateTimer();
            moves = 0; // Reset langkah
            updateMovesDisplay();
            disableAllButtons(); // Nonaktifkan tombol saat mengacak

            // Atur ulang potongan ke posisi terpecahkan terlebih dahulu
            for (let i = 0; i < puzzlePieces.length; i++) {
                puzzlePieces[i].currentX = puzzlePieces[i].originalX;
                puzzlePieces[i].currentY = puzzlePieces[i].originalY;
                puzzlePieces[i].isEmpty = (i === gridSize * gridSize - 1);
            }
            emptyPieceIndex = gridSize * gridSize - 1; // Pastikan kosong di kanan bawah

            drawPuzzle(); // Gambar ulang puzzle dalam keadaan terpecahkan

            // Lakukan sejumlah besar gerakan acak untuk mengacak puzzle
            const numShuffles = gridSize * gridSize * 100; // Jumlah gerakan acak yang lebih besar
            for (let i = 0; i < numShuffles; i++) {
                const possibleMoves = getPossibleMoves(emptyPieceIndex);
                if (possibleMoves.length > 0) {
                    const randomIndex = Math.floor(Math.random() * possibleMoves.length);
                    const clickedIndex = possibleMoves[randomIndex];
                    
                    const clickedPiece = puzzlePieces[clickedIndex];
                    const emptyPiece = puzzlePieces[emptyPieceIndex];

                    const tempX = clickedPiece.currentX;
                    const tempY = clickedPiece.currentY;

                    clickedPiece.currentX = emptyPiece.currentX;
                    clickedPiece.currentY = emptyPiece.currentY;
                    emptyPiece.currentX = tempX;
                    emptyPiece.currentY = tempY;

                    emptyPieceIndex = clickedIndex;
                }
            }
            drawPuzzle(); // Gambar ulang setelah mengacak
            isShuffled = true;
            shuffling = false;
            updateSolveStatusDisplay('Mulai Main!');
            startTimer(); // Mulai timer setelah mengacak selesai
            enableAllButtons(); // Aktifkan kembali tombol
        });

        // =====================================================================
        // Fungsi untuk menyelesaikan puzzle (Algoritma BFS)
        // =====================================================================
        solveButton.addEventListener('click', async () => {
            if (!puzzleReady || solving || shuffling || !isShuffled) {
                showMessageBox("Puzzle harus diacak terlebih dahulu untuk diselesaikan.");
                return;
            }

            solving = true;
            isProcessingClick = true;
            updateSolveStatusDisplay('Menyelesaikan...');
            stopTimer(); // Hentikan timer saat menyelesaikan
            disableAllButtons(); // Nonaktifkan tombol saat menyelesaikan

            const initialState = puzzlePieces.map(p => ({ id: p.id, currentX: p.currentX, currentY: p.currentY, isEmpty: p.isEmpty }));
            const initialEmptyIndex = emptyPieceIndex;

            // State representasi: array urutan ID potongan, dengan -1 untuk ruang kosong
            function getState(pieces) {
                const state = Array(gridSize * gridSize);
                pieces.forEach(p => {
                    const col = Math.round(p.currentX / pieceSize);
                    const row = Math.round(p.currentY / pieceSize);
                    state[row * gridSize + col] = p.isEmpty ? -1 : p.id;
                });
                return state.join(',');
            }

            function getPiecesFromState(stateString) {
                const stateArray = stateString.split(',').map(Number);
                const pieces = Array(gridSize * gridSize).fill(null).map((_, i) => ({
                    id: i,
                    originalX: (i % gridSize) * pieceSize,
                    originalY: Math.floor(i / gridSize) * pieceSize,
                    currentX: 0, // Akan diisi
                    currentY: 0, // Akan diisi
                    isEmpty: false
                }));
                let emptyIdx = -1;

                stateArray.forEach((id, index) => {
                    const piece = pieces.find(p => p.id === id); // Cari berdasarkan ID asli
                    if (id === -1) {
                        // Potongan kosong
                        pieces[index] = {
                            id: -1, // ID unik untuk potongan kosong
                            currentX: (index % gridSize) * pieceSize,
                            currentY: Math.floor(index / gridSize) * pieceSize,
                            isEmpty: true
                        };
                        emptyIdx = index;
                    } else if (piece) { // Jika potongan asli ditemukan
                        piece.currentX = (index % gridSize) * pieceSize;
                        piece.currentY = Math.floor(index / gridSize) * pieceSize;
                        piece.isEmpty = false;
                    }
                });
                return { pieces, emptyIdx };
            }

            // Target state
            const targetState = Array(gridSize * gridSize).fill(null).map((_, i) => i).join(',');
            const emptyTargetState = targetState.replace(`,${gridSize * gridSize - 1}`, ',-1'); // Pastikan -1 di akhir

            const queue = [[getState(initialState), initialEmptyIndex, []]]; // [state, emptyIndex, path]
            const visited = new Set();
            visited.add(getState(initialState));

            let solutionPath = null;

            while (queue.length > 0) {
                const [currentStateStr, currentEmptyIdx, path] = queue.shift();
                
                // Reconstruct pieces for current state
                const currentPieces = getPiecesFromState(currentStateStr).pieces;

                // Check if solved (ignoring exact object references, just IDs and positions)
                let isCurrentStateSolved = true;
                currentPieces.forEach(p => {
                    const col = Math.round(p.currentX / pieceSize);
                    const row = Math.round(p.currentY / pieceSize);
                    const originalCol = p.id % gridSize;
                    const originalRow = Math.floor(p.id / gridSize);

                    // Untuk potongan kosong, posisi yang benar adalah kanan bawah
                    if (p.isEmpty) {
                        if (col !== gridSize - 1 || row !== gridSize - 1) {
                            isCurrentStateSolved = false;
                        }
                    } else { // Untuk potongan angka
                        if (col !== originalCol || row !== originalRow) {
                            isCurrentStateSolved = false;
                        }
                    }
                });
                if (isCurrentStateSolved) {
                    solutionPath = path;
                    break;
                }

                const possibleMoves = getPossibleMoves(currentEmptyIdx);

                for (const moveIndex of possibleMoves) {
                    const newPieces = JSON.parse(JSON.stringify(currentPieces)); // Deep copy
                    const newEmptyIdx = moveIndex;
                    
                    const clickedPiece = newPieces[moveIndex];
                    const emptyPiece = newPieces[currentEmptyIdx];

                    // Tukar posisi currentX/Y saja
                    const tempX = clickedPiece.currentX;
                    const tempY = clickedPiece.currentY;
                    clickedPiece.currentX = emptyPiece.currentX;
                    clickedPiece.currentY = emptyPiece.currentY;
                    emptyPiece.currentX = tempX;
                    emptyPiece.currentY = tempY;

                    // Tandai ulang potongan kosong
                    clickedPiece.isEmpty = false;
                    emptyPiece.isEmpty = true;

                    const newStateStr = getState(newPieces);
                    if (!visited.has(newStateStr)) {
                        visited.add(newStateStr);
                        queue.push([newStateStr, newEmptyIdx, [...path, moveIndex]]); // Tambahkan indeks potongan yang dipindahkan
                    }
                }
            }

            if (solutionPath) {
                console.log("Solusi ditemukan. Jumlah langkah:", solutionPath.length);
                // Animasikan solusi langkah demi langkah
                for (let i = 0; i < solutionPath.length; i++) {
                    const targetMoveIndex = solutionPath[i];
                    
                    // Temukan potongan yang akan digeser menuju ruang kosong saat ini
                    const pieceToMove = puzzlePieces.find(p => p.id === targetMoveIndex);

                    if (pieceToMove) { // Pastikan potongan ditemukan
                        const emptyPiece = puzzlePieces[emptyPieceIndex];

                        // Gerakkan potongan secara visual dan logis
                        const tempX = pieceToMove.currentX;
                        const tempY = pieceToMove.currentY;

                        pieceToMove.currentX = emptyPiece.currentX;
                        pieceToMove.currentY = emptyPiece.currentY;
                        emptyPiece.currentX = tempX;
                        emptyPiece.currentY = tempY;

                        // Perbarui indeks potongan kosong
                        emptyPieceIndex = puzzlePieces.indexOf(pieceToMove);

                        moves++;
                        updateMovesDisplay();
                        drawPuzzle();
                        await new Promise(resolve => setTimeout(resolve, 50)); // Jeda untuk animasi
                    } else {
                         console.error("Potongan yang akan digeser tidak ditemukan:", targetMoveIndex);
                    }
                }
                updateSolveStatusDisplay('Selesai!');
                checkWin();
            } else {
                updateSolveStatusDisplay('Tidak dapat diselesaikan.');
                showMessageBox("Puzzle tidak dapat diselesaikan.");
            }
            solving = false;
            isProcessingClick = false;
            enableAllButtons(); // Aktifkan kembali tombol setelah selesai
            startTimer(); // Mulai kembali timer setelah penyelesaian
        });


        // =====================================================================
        // Mendapatkan daftar kemungkinan gerakan dari ruang kosong
        // =====================================================================
        function getPossibleMoves(currentEmptyIndex) {
            const emptyCol = currentEmptyIndex % gridSize;
            const emptyRow = Math.floor(currentEmptyIndex / gridSize);
            const possibleMoves = [];

            // Tetangga: atas, bawah, kiri, kanan
            const directions = [
                { dr: -1, dc: 0 }, // Atas
                { dr: 1, dc: 0 },  // Bawah
                { dr: 0, dc: -1 }, // Kiri
                { dr: 0, dc: 1 }   // Kanan
            ];

            for (const dir of directions) {
                const newRow = emptyRow + dir.dr;
                const newCol = emptyCol + dir.dc;

                if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                    const newIndex = newRow * gridSize + newCol;
                    possibleMoves.push(newIndex);
                }
            }
            return possibleMoves;
        }

        // =====================================================================
        // Periksa Kondisi Menang
        // =====================================================================
        function checkWin() {
            let solved = true;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                // Potongan kosong harus berada di posisi terakhir
                if (piece.isEmpty) {
                    if (i !== gridSize * gridSize - 1) {
                        solved = false;
                        break;
                    }
                } else {
                    // Potongan lainnya harus berada di posisi aslinya
                    if (piece.currentX !== piece.originalX || piece.currentY !== piece.originalY) {
                        solved = false;
                        break;
                    }
                }
            }

            if (solved) {
                updateSolveStatusDisplay('Selesai!');
                stopTimer();
                puzzleCanvas.classList.add('puzzle-solved-animation');
                showMessageBox(`Selamat! Puzzle selesai dalam ${moves} langkah dan ${seconds} detik!`);
            }
            return solved;
        }

        // =====================================================================
        // Reset Puzzle ke Urutan Awal
        // =====================================================================
        resetButton.addEventListener('click', () => {
            if (!puzzleReady || solving || shuffling) return;

            solving = false;
            shuffling = false;
            isProcessingClick = false;
            stopTimer();
            seconds = 0;
            moves = 0;
            updateMovesDisplay();
            updateTimer();
            updateSolveStatusDisplay('Siap');
            
            // Atur ulang posisi potongan ke posisi aslinya
            for (let i = 0; i < puzzlePieces.length; i++) {
                puzzlePieces[i].currentX = puzzlePieces[i].originalX;
                puzzlePieces[i].currentY = puzzlePieces[i].originalY;
                puzzlePieces[i].isEmpty = (i === gridSize * gridSize - 1); // Potongan terakhir adalah kosong
            }
            emptyPieceIndex = gridSize * gridSize - 1;
            isShuffled = false;
            drawPuzzle();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            enableAllButtons();
        });

        // =====================================================================
        // Mengaktifkan dan Menonaktifkan Tombol
        // =====================================================================
        function disableAllButtons() {
            shuffleButton.disabled = true;
            solveButton.disabled = true;
            resetButton.disabled = true;
            toggleNumbersButton.disabled = true;
            imageUpload.disabled = true;
            gridSizeSelect.disabled = true;
            viewOriginalImageButton.disabled = true;
        }

        function enableAllButtons() {
            shuffleButton.disabled = false;
            solveButton.disabled = false;
            resetButton.disabled = false;
            toggleNumbersButton.disabled = false;
            imageUpload.disabled = false;
            gridSizeSelect.disabled = false;
            viewOriginalImageButton.disabled = false;
        }
        
        // =====================================================================
        // Penanganan Responsivitas Ukuran Jendela
        // =====================================================================
        window.addEventListener('resize', () => {
            console.log("Window resized. Re-initializing puzzle for new dimensions.");
            if (originalImage.src && originalImage.complete && originalImage.naturalWidth > 0) {
                 initializePuzzle(); // Ini akan mengatur ulang puzzle ke keadaan terpecahkan
                 if (isShuffled) { // Jika sebelumnya diacak, acak ulang
                     shufflePuzzle(); // Ini akan mengacak dan memulai timer
                 } else {
                     drawPuzzle(); // Jika tidak diacak, hanya gambar ulang (tetap terpecahkan)
                 }
            } else {
                // Gambar ulang placeholder jika tidak ada gambar yang dimuat
                const placeholderSize = 600;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`;
                // initializePuzzle() will be called when placeholder image loads
            }
        });

        // =====================================================================
        // Handle "View Original Image" Button
        // =====================================================================
        viewOriginalImageButton.addEventListener('click', () => {
            if (originalImage.src && originalImage.complete && originalImage.naturalWidth > 0) { // Ensure image is loaded before displaying
                fullImageDisplay.src = originalImage.src;
                mainContent.classList.add('main-content-hidden'); // Hide main puzzle UI
                originalImageDisplayContainer.classList.add('show'); // Show original image container
                originalImageDisplayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                console.log('Displaying original image.');
            } else {
                showMessageBox("Tidak ada gambar yang dimuat untuk ditampilkan.");
                console.warn('Attempted to view original image, but no image loaded.');
            }
        });

        backToPuzzleButton.addEventListener('click', () => {
            originalImageDisplayContainer.classList.remove('show'); // Hide original image container
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            puzzleCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Scroll to puzzle
            console.log('Returning to puzzle view.');
        });

        // =====================================================================
        // Inisialisasi Awal (gambar placeholder)
        // =====================================================================
        window.onload = async () => {
            loadPreferences(); // Muat preferensi tersimpan terlebih dahulu
            console.log('Window loaded. Initializing with placeholder...');

            // Atur ukuran kanvas awal di sini untuk memastikan terlihat bahkan sebelum gambar dimuat
            // Ini adalah pendekatan sementara untuk memastikan kanvas memiliki ukuran awal yang terlihat
            // sampai gambar sebenarnya dimuat dan initializePuzzle() dipanggil.
            const initialCanvasWidth = Math.max(300, Math.min(puzzleCanvas.parentElement.clientWidth, window.innerHeight * 0.75));
            puzzleCanvas.width = initialCanvasWidth;
            puzzleCanvas.height = initialCanvasWidth; // Untuk sliding puzzle, biasanya persegi
            
            originalImage.onload = () => {
                console.log('Initial placeholder image loaded. Initializing puzzle components.');
                initializePuzzle();
                // Untuk sliding puzzle, biasanya dimulai dalam keadaan terpecahkan, lalu diacak secara manual.
                // Tidak perlu shuffle otomatis di sini unless explicitly requested by user in future.
                // drawPuzzle(); // Initial draw is part of initializePuzzle
            };
            originalImage.onerror = () => {
                console.error('Gagal memuat gambar placeholder awal.');
                showMessageBox("Gagal memuat gambar placeholder awal. Harap periksa koneksi internet Anda.");
                puzzleReady = false;
                drawPuzzle(); // Gambar teks 'Unggah atau Pilih Gambar'
            };
            const placeholderSize = 600; 
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`; 
            drawPuzzle(); // Penggambaran awal untuk segera menunjukkan teks placeholder
        };

    </script>
</body>
</html>

