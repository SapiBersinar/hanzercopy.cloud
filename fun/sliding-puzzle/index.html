<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Interaktif</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif';
            /* Latar belakang gradient modern */
            background-image: linear-gradient(to bottom right, #a78bfa, #818cf8, #6366f1); /* Ungu-biru gradient */
            background-attachment: fixed; /* Memastikan gradient tetap saat scroll */
            overflow-x: hidden; /* Mencegah overflow horizontal */
        }
        /* Styling untuk canvas */
        canvas {
            display: block; /* Menghilangkan spasi ekstra di bawah canvas */
            background-color: #ffffff; /* Latar belakang canvas putih bersih */
            border: 3px solid #4f46e5; /* Border ungu tua (indigo-600) */
            border-radius: 0.75rem; /* Sudut membulat */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: manipulation; /* Memungkinkan event sentuhan */
            -webkit-user-select: none; /* Non-seleksi teks untuk iOS */
            -moz-user-select: none; /* Non-seleksi teks untuk Firefox */
            -ms-user-select: none; /* Non-seleksi teks untuk IE/Edge */
            user-select: none; /* Non-seleksi teks */
            /* Transisi untuk animasi kemenangan */
            transition: transform 0.5s ease-out, border 0.5s ease-out, box-shadow 0.5s ease-out;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            border: 2px solid #4f46e5; /* Border ungu tua */
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        /* Styling untuk tombol */
        .btn-primary-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Indigo ke Violet */
            transition: background-image 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Lebih gelap saat hover */
        }
        .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #3730a3, #5b21b6); /* Lebih gelap lagi saat ditekan */
            transform: scale(0.98);
        }

        .btn-purple {
            background-color: #a855f7; /* Purple-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-purple:hover {
            background-color: #9333ea; /* Purple-600 */
        }
        .btn-purple:active {
            background-color: #7e22ce; /* Purple-700 saat ditekan */
            transform: scale(0.98);
        }

        .btn-green-solve {
            background-color: #10b981; /* Green-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-green-solve:hover {
            background-color: #059669;
        }
        .btn-green-solve:active {
            background-color: #047857;
            transform: scale(0.98);
        }

        .btn-gray { /* General gray button for Reset */
            background-color: #6b7280; /* Gray-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-gray:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        .btn-gray:active {
            background-color: #374151; /* Gray-700 saat ditekan */
            transform: scale(0.98);
        }

        /* Styling untuk gambar contoh yang bisa diklik */
        .sample-image-container {
            width: 80px; /* Lebar tetap untuk gambar contoh */
            height: 80px; /* Tinggi tetap untuk gambar contoh */
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out;
            border: 2px solid transparent; /* Border transparan default */
        }
        .sample-image-container:hover {
            transform: scale(1.05); /* Sedikit membesar saat hover */
            border-color: #6366f1; /* Warna border saat hover */
        }
        .sample-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Pastikan gambar mengisi container tanpa distorsi */
            display: block;
        }


        /* Kelas untuk animasi kemenangan */
        .puzzle-solved-animation {
            animation: puzzle-bounce 0.5s ease-out forwards;
            border-color: #10b981; /* Green-500 for solved state */
            box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.7), 0 0 30px 10px rgba(16, 185, 129, 0.5); /* Glowing effect */
        }

        @keyframes puzzle-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }

        /* Container untuk tampilan gambar asli di bawah */
        .original-image-display-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 3xl; /* Match main container width */
        }
        .original-image-display-container.show {
            display: flex;
        }
        .original-image-display-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        .original-image-display-container button {
            margin-top: 0; /* Adjust margin if needed */
        }

        /* Kelas untuk menyembunyikan main-content saat gambar asli ditampilkan */
        .main-content-hidden {
            display: none;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-gray-900">

    <div id="mainContent" class="w-full max-w-3xl bg-white p-6 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-6">Sliding Puzzle Interaktif</h1>

        <div class="mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-gray-700 mb-2">Unggah Foto Anda:</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
        </div>

        <div class="mb-6 text-center">
            <label class="block text-lg font-medium text-gray-700 mb-2">Atau Pilih Gambar Contoh:</label>
            <div id="sampleImageContainer" class="flex flex-wrap justify-center gap-2">
                <div class="sample-image-container" data-src="https://github.com/SapiBersinar/hanzercopy.cloud/blob/main/fun/sliding-puzzle/gambar/1.jpg">
                    <img src="https://github.com/SapiBersinar/hanzercopy.cloud/blob/main/fun/sliding-puzzle/gambar/1.jpg" alt="Contoh Gambar Baru">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/2.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/2.jpg" alt="Contoh Gambar 1">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/3.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/3.jpg" alt="Contoh Gambar 2">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/4.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/4.jpg" alt="Contoh Gambar 3">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.png" alt="Contoh Gambar 4">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.jpg">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/hanzercopy.cloud/main/fun/sliding-puzzle/gambar/5.jpg" alt="Contoh Gambar 5">
                </div>
            </div>
        </div>

        <div class="mb-6 text-center">
            <label for="gridSizeSelect" class="block text-lg font-medium text-gray-700 mb-2">Pilih Ukuran Puzzle:</label>
            <select id="gridSizeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                <option value="3" selected>3x3</option>
                <option value="4">4x4</option>
                <option value="5">5x5</option>
            </select>
        </div>

        <div class="mb-6 text-center">
            <label for="puzzleModeSelect" class="block text-lg font-medium text-gray-700 mb-2">Pilih Mode Puzzle:</label>
            <select id="puzzleModeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                <option value="sliding" selected>Sliding Puzzle (Default)</option>
                <option value="jigsaw">Jigsaw (Tanpa Nomor)</option>
            </select>
        </div>
        
        <div class="flex justify-center gap-8 mb-4 text-center">
            <div class="text-lg font-semibold text-gray-700">
                Gerakan: <span id="moveCounter" class="text-indigo-700">0</span>
            </div>
            <div class="text-lg font-semibold text-gray-700">
                Waktu: <span id="timerDisplay" class="text-indigo-700">00:00</span>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="shuffleButton" class="btn-primary-gradient text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Acak
            </button>
            <button id="undoButton" class="btn-purple text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2">
                Urungkan
            </button>
            <button id="solveButton" class="btn-green-solve text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                Selesaikan Otomatis
            </button>
            <button id="resetButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Reset Puzzle
            </button>
        </div>
        <div id="solveStatus" class="text-center text-red-600 font-medium mb-4" style="min-height: 24px;"></div>


        <div class="relative w-full max-w-full flex justify-center items-center overflow-hidden mb-6" style="min-height: 250px;">
            <canvas id="puzzleCanvas" class="w-full h-auto max-w-full"></canvas>
        </div>

        <div class="text-center mt-4">
            <button id="viewOriginalImageButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Lihat Gambar Asli
            </button>
        </div>
        
        <p class="text-center text-gray-600 text-sm italic mt-4">Klik potongan yang berdekatan dengan tempat kosong untuk memindahkannya.</p>
        
    </div>

    <div id="messageBoxContainer"></div>

    <div id="originalImageDisplayContainer" class="original-image-display-container">
        <img id="fullImageDisplay" src="" alt="Gambar Asli">
        <button id="backToPuzzleButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md">
            Kembali ke Puzzle
        </button>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSelect = document.getElementById('gridSizeSelect');
        const puzzleModeSelect = document.getElementById('puzzleModeSelect');
        const shuffleButton = document.getElementById('shuffleButton');
        const undoButton = document.getElementById('undoButton');
        const solveButton = document.getElementById('solveButton');
        const resetButton = document.getElementById('resetButton');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const ctx = puzzleCanvas.getContext('2d');
        const messageBoxContainer = document.getElementById('messageBoxContainer');
        const moveCounterDisplay = document.getElementById('moveCounter');
        const timerDisplay = document.getElementById('timerDisplay');
        const solveStatusDisplay = document.getElementById('solveStatus');
        const viewOriginalImageButton = document.getElementById('viewOriginalImageButton');
        const originalImageDisplayContainer = document.getElementById('originalImageDisplayContainer');
        const fullImageDisplay = document.getElementById('fullImageDisplay');
        const backToPuzzleButton = document.getElementById('backToPuzzleButton');
        const mainContent = document.getElementById('mainContent'); // Reference to the main puzzle container

        // Sample image elements
        const sampleImageContainers = document.querySelectorAll('.sample-image-container');
        let originalImage = new Image();
        let puzzlePieces = [];
        let gridSize = parseInt(gridSizeSelect.value);
        let currentPuzzleMode = puzzleModeSelect.value;
        let pieceWidth;
        let pieceHeight;
        let blankPieceIndex;
        let isShuffled = false;
        let puzzleReady = false;
        let moves = 0;
        let isProcessingClick = false; // Flag for manual click animation
        let solving = false; // Flag for auto-solve process
        let shuffling = false; // Flag for initial shuffle animation
        let undoStack = [];
        const maxUndoStates = 50;

        let startTime;
        let timerInterval;
        let hasMadeFirstMove = false; // New flag for timer start
        const animationDuration = 200; // Manual move animation duration (ms)
        
        // Dynamic shuffle animation parameters
        const getShuffleParams = (gridSize) => {
            switch (gridSize) {
                case 3: return { numMoves: 220, visualDelay: 16 }; // ~3.5s total (220 * 16ms)
                case 4: return { numMoves: 240, visualDelay: 17 }; // ~4s total (240 * 17ms)
                case 5: return { numMoves: 500, visualDelay: 10 }; // ~5s total (500 * 10ms)
                default: return { numMoves: 220, visualDelay: 16 };
            }
        };

        // Delay per gerakan untuk auto-solve, tergantung ukuran grid
        const getAutoSolveStepDelay = (gridSize) => {
            if (gridSize === 3 || gridSize === 4) return 1500; // 1.5 seconds
            if (gridSize === 5) return 3500; // 3.5 seconds
            return 1500; // Default
        };
        
        const maxStatesToExploreForBFS = 1000000;
        // For hover effects on puzzle pieces
        let hoveredPiece = null;
        // =====================================================================
        // Utility function for notifications (replaces alert())
        // =====================================================================
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p class="text-xl font-semibold mb-4">${message}</p>
                <button id="closeMessageBox" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300">Oke</button>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            messageBoxContainer.appendChild(overlay);
            messageBoxContainer.appendChild(messageBox);

            document.getElementById('closeMessageBox').onclick = () => {
                messageBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Function to check puzzle solvability
        // =====================================================================
        function isPuzzleSolvable(piecesArray, currentGridSize) {
            // Get the current order of original IDs of pieces
            const currentOrder = Array(currentGridSize * currentGridSize).fill(0);
            const piecePositions = new Map(); // Map originalId to current index in 1D array
            
            piecesArray.forEach(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                const index = row * currentGridSize + col;
                currentOrder[index] = p.id;
                piecePositions.set(p.id, index);
            });
            // Find the blank piece and its row (0-indexed from top)
            const blankPiece = piecesArray.find(p => p.isBlank);
            const blankIndex = piecePositions.get(blankPiece.id);
            const blankRowFromTop = Math.floor(blankIndex / currentGridSize);
            // Create a 1D array of non-blank piece IDs in their current reading order
            const flatState = currentOrder.filter(id => id !== blankPiece.id);
            let inversions = 0;
            for (let i = 0; i < flatState.length - 1; i++) {
                for (let j = i + 1; j < flatState.length; j++) {
                    if (flatState[i] > flatState[j]) {
                        inversions++;
                    }
                }
            }

            // Solvability rules based on grid size and blank tile position
            if (currentGridSize % 2 === 1) { // Odd grid size
                return inversions % 2 === 0;
            } else { // Even grid size
                const blankRowFromBottom = currentGridSize - blankRowFromTop; // 1-indexed from bottom
                if (blankRowFromBottom % 2 === 1) { // Blank on an odd row from bottom
                    return inversions % 2 === 0;
                } else { // Blank on an even row from bottom
                    return inversions % 2 === 1;
                }
            }
        }


        // =====================================================================
        // Handle Image Upload
        // =====================================================================
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage.onload = async () => {
                        // Check aspect ratio and inform user if cropped
                        if (originalImage.width !== originalImage.height) {
                            showMessageBox("Gambar dipotong menjadi persegi (1:1) dari bagian tengah untuk puzzle.");
                        }
                        initializePuzzle(); // Resets to solved state
                        await animateShuffle(); // Shuffles and ensures solvability
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        // =====================================================================
        // Handle Sample Image Selection
        // =====================================================================
        sampleImageContainers.forEach(container => {
            container.addEventListener('click', async (event) => {
                const imageUrl = container.dataset.src;
                if (!imageUrl) return;

                if (shuffling || solving || isProcessingClick) return;

                solveStatusDisplay.textContent = 'Memuat gambar contoh...';
                disableAllButtons();

                originalImage.onload = async () => {
                    initializePuzzle(); // Resets to solved state
                    await animateShuffle(); // Shuffles and ensures solvability
                    solveStatusDisplay.textContent = '';
                    enableAllButtons();
                };
                originalImage.onerror = () => {
                    showMessageBox("Gagal memuat gambar contoh. Silakan coba lagi atau unggah gambar Anda sendiri.");
                    enableAllButtons();
                    solveStatusDisplay.textContent = '';
                };
                originalImage.src = imageUrl;
            });
        });


        // =====================================================================
        // Handle Grid Size and Puzzle Mode Changes (with Local Storage)
        // =====================================================================
        gridSizeSelect.addEventListener('change', async (event) => {
            gridSize = parseInt(event.target.value);
            savePreferences(); // Save preference
            if (puzzleReady) {
                initializePuzzle(); // Resets to solved state
                await animateShuffle(); // Shuffles and ensures solvability
            } else {
                const placeholderSize = 600;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`;
            }
        });

        puzzleModeSelect.addEventListener('change', async (event) => {
            currentPuzzleMode = event.target.value;
            savePreferences(); // Save preference
            if (puzzleReady) {
                initializePuzzle(); // Resets to solved state
                await animateShuffle(); // Always re-shuffle when mode changes (if puzzle ready)
            } else {
                drawPuzzle(); // Just draw if not puzzleReady (e.g., initial placeholder)
            }
        });
        // =====================================================================
        // Initialize Puzzle (Adapts image to 1:1, sets up pieces)
        // =====================================================================
        function initializePuzzle() {
            const container = puzzleCanvas.parentElement;
            const maxAllowedDimension = Math.min(container.clientWidth, window.innerHeight * 0.75);

            puzzleCanvas.width = maxAllowedDimension;
            puzzleCanvas.height = maxAllowedDimension;

            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            // Calculate source size for 1:1 aspect ratio cropping
            let sourceSize = Math.min(originalImage.width, originalImage.height);
            let offsetX = (originalImage.width - sourceSize) / 2;
            let offsetY = (originalImage.height - sourceSize) / 2;

            puzzlePieces = [];
            const totalPieces = gridSize * gridSize;
            for (let i = 0; i < totalPieces; i++) {
                puzzlePieces.push({
                    id: i,
                    originalIndex: i, // Store original index to sort back to solved state
                    currentX: (i % gridSize) * pieceWidth,
                    currentY: Math.floor(i / gridSize) * pieceHeight,
                    sourceX: offsetX + (sourceSize / gridSize) * (i % gridSize),
                    sourceY: offsetY + (sourceSize / gridSize) * Math.floor(i / gridSize),
                    sourceWidth: sourceSize / gridSize,
                    sourceHeight: sourceSize / gridSize,
                    isBlank: false
                });
            }
            blankPieceIndex = totalPieces - 1;
            puzzlePieces[blankPieceIndex].isBlank = true;
            isShuffled = false; 
            moves = 0;
            undoStack = [];
            updateMoveCounter();
            stopTimer(); // Ensure timer is stopped
            timerDisplay.textContent = '00:00';
            hasMadeFirstMove = false; // Reset first move flag for timer
            drawPuzzle(); // Draw in solved state

            puzzleCanvas.classList.remove('puzzle-solved-animation');
            solveStatusDisplay.textContent = '';
            puzzleReady = true;
        }

        // =====================================================================
        // Recalculate piece positions and redraw (used for resize without resetting state)
        // =====================================================================
        function recalculatePiecePositionsAndRedraw() {
            const container = puzzleCanvas.parentElement;
            const maxAllowedDimension = Math.min(container.clientWidth, window.innerHeight * 0.75);
            puzzleCanvas.width = maxAllowedDimension;
            puzzleCanvas.height = maxAllowedDimension;
            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            // Re-assign currentX/currentY for each piece based on its *current index in the puzzlePieces array*
            // This preserves the current (shuffled or solved) arrangement
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });

            drawPuzzle();
        }

        // =====================================================================
        // Draw Puzzle on Canvas
        // =====================================================================
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
            puzzlePieces.forEach(piece => {
                if (!piece.isBlank) {
                    ctx.drawImage(
                        originalImage,
                        piece.sourceX, piece.sourceY,
                        piece.sourceWidth, piece.sourceHeight,
                        piece.currentX, piece.currentY,
                        pieceWidth, pieceHeight
                    );

                    // Draw border around pieces
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);

                    // Hover effect (only when no animation or auto-solve in progress)
                    if (hoveredPiece && hoveredPiece.id === piece.id && !isProcessingClick && !solving && !shuffling) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; // Semi-transparent overlay
                        ctx.fillRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                        ctx.strokeStyle = '#9333ea'; // Purple for hover border
                        ctx.lineWidth = 3;
                        ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                    }

                    // Draw numbers only if not in Jigsaw mode
                    if (currentPuzzleMode === 'sliding') {
                        ctx.fillStyle = '#312e81';
                        ctx.font = `${Math.min(pieceWidth, pieceHeight) * 0.3}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            piece.id + 1,
                            piece.currentX + pieceWidth / 2,
                            piece.currentY + pieceHeight / 2
                        );
                    }
                } else {
                    // Blank piece styling
                    ctx.fillStyle = '#e0e7ff';
                    ctx.fillRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                }
            });
        }

        // =====================================================================
        // Shuffle Puzzle with visual animation and ensure solvability
        // =====================================================================
        async function animateShuffle() {
            if (!puzzleReady || shuffling || solving) {
                return;
            }
            shuffling = true;
            disableAllButtons();
            solveStatusDisplay.textContent = 'Mengacak puzzle...';
            const originalBlankId = gridSize * gridSize - 1; // ID of the blank piece
            const { numMoves, visualDelay } = getShuffleParams(gridSize);
            const shuffleStartTime = Date.now();
            let currentSolvable = false;
            let shuffleAttempts = 0;
            const maxShuffleAttempts = 10; // Limit attempts for re-shuffling to find a solvable one

            let finalPuzzleOrder = null; // To store the *logical* order of piece IDs for the solvable state

            while (!currentSolvable && shuffleAttempts < maxShuffleAttempts) {
                // Reset puzzlePieces to the solved state (logically and visually) for this attempt's animation
                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                    piece.isBlank = (piece.id === originalBlankId);
                });
                drawPuzzle(); // Ensure it starts from solved for each attempt

                // Perform the visual shuffle animation for `numMoves`
                let currentVisualPieces = puzzlePieces.map(p => ({ ...p })); // Deep copy for animation state
                let currentVisualBlankPiece = currentVisualPieces.find(p => p.isBlank);
                for (let i = 0; i < numMoves; i++) {
                    if (!shuffling) { // Check if shuffle was externally stopped
                        break;
                    }

                    const blankCol = Math.round(currentVisualBlankPiece.currentX / pieceWidth);
                    const blankRow = Math.round(currentVisualBlankPiece.currentY / pieceHeight);

                    const possibleMoves = [];
                    if (blankRow > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow - 1));
                    if (blankRow < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow + 1));
                    if (blankCol > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol - 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    if (blankCol < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol + 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    const validMoves = possibleMoves.filter(p => p && !p.isBlank);

                    if (validMoves.length === 0) continue;

                    const pieceToMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    // Perform the swap of visual coordinates on `currentVisualPieces`
                    const tempX = pieceToMove.currentX;
                    const tempY = pieceToMove.currentY;

                    pieceToMove.currentX = currentVisualBlankPiece.currentX;
                    pieceToMove.currentY = currentVisualBlankPiece.currentY;

                    currentVisualBlankPiece.currentX = tempX;
                    currentVisualBlankPiece.currentY = tempY;
                    // Update the array order of `currentVisualPieces` to reflect the new visual positions
                    const pieceToMoveIndexInArray = currentVisualPieces.indexOf(pieceToMove);
                    const blankIndexInArray = currentVisualPieces.indexOf(currentVisualBlankPiece);
                    [currentVisualPieces[pieceToMoveIndexInArray], currentVisualPieces[blankIndexInArray]] = 
                    [currentVisualPieces[blankIndexInArray], currentVisualPieces[pieceToMoveIndexInArray]];
                    // Temporarily assign currentVisualPieces to puzzlePieces for drawing
                    puzzlePieces = currentVisualPieces;
                    drawPuzzle(); // Redraw after each step
                    await new Promise(resolve => setTimeout(resolve, visualDelay));
                }

                // After the visual animation, check if the resulting state is solvable
                if (isPuzzleSolvable(puzzlePieces, gridSize)) {
                    currentSolvable = true;
                    finalPuzzleOrder = puzzlePieces.map(p => p.id); // Store the IDs order of this solvable state
                } else {
                    shuffleAttempts++;
                    // If not solvable, the loop will restart, re-initializing and re-animating
                    console.warn(`Attempt ${shuffleAttempts}: Shuffled puzzle is not solvable. Retrying...`);
                }
            } // End of while loop (attempting to find a solvable animated shuffle)

            if (!shuffling) { // If shuffle was cancelled during animation
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                enableAllButtons();
                return;
            }

            if (currentSolvable && finalPuzzleOrder) {
                // Ensure `puzzlePieces` is exactly the solvable state found, even if visual steps deviated slightly
                let correctedPuzzlePieces = [];
                for (let i = 0; i < finalPuzzleOrder.length; i++) {
                    const pieceId = finalPuzzleOrder[i];
                    const originalPieceData = puzzlePieces.find(p => p.id === pieceId);
                    correctedPuzzlePieces.push({
                        ...originalPieceData,
                        currentX: (i % gridSize) * pieceWidth,
                        currentY: Math.floor(i / gridSize) * pieceHeight,
                        isBlank: (pieceId === originalBlankId)
                    });
                }
                puzzlePieces = correctedPuzzlePieces;
                drawPuzzle(); // Final draw to the guaranteed solvable state

                const shuffleEndTime = Date.now();
                const elapsedTimeSeconds = ((shuffleEndTime - shuffleStartTime) / 1000).toFixed(2);

                isShuffled = true;
                moves = 0;
                undoStack = [];
                updateMoveCounter();
                hasMadeFirstMove = false; // Reset for timer to start on first user move
                
                shuffling = false;
                enableAllButtons();

                solveStatusDisplay.textContent = `Berhasil mengacak ${numMoves} gerakan dalam ${elapsedTimeSeconds} detik.`;
            } else {
                shuffling = false;
                enableAllButtons();
                solveStatusDisplay.textContent = `Gagal menemukan puzzle yang dapat dipecahkan setelah ${maxShuffleAttempts} percobaan. Coba acak ulang.`;
                showMessageBox("Gagal menemukan puzzle yang dapat dipecahkan setelah beberapa kali percobaan. Harap coba lagi atau unggah gambar yang berbeda.");
                initializePuzzle(); // Revert to initial solved state
            }
        }


        shuffleButton.addEventListener('click', animateShuffle);
        // =====================================================================
        // Undo Puzzle Move
        // =====================================================================
        undoButton.addEventListener('click', () => {
            if (isProcessingClick || solving || shuffling) return;

            if (undoStack.length > 0) {
                const prevState = undoStack.pop();
                puzzlePieces = prevState.pieces.map(p => ({ ...p }));
                moves = prevState.moves;
                isShuffled = prevState.isShuffled;
                currentPuzzleMode = prevState.puzzleMode;

                // Re-calculate positions based on the restored array order
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                });

                updateMoveCounter();
                drawPuzzle();
                puzzleModeSelect.value = currentPuzzleMode;
            } else {
                showMessageBox("Tidak ada gerakan untuk di-undo.");
            }
        });

        // =====================================================================
        // Reset Puzzle to Original Order
        // =====================================================================
        resetButton.addEventListener('click', () => {
            if (!puzzleReady) {
                showMessageBox("Silakan unggah gambar terlebih dahulu.");
                return;
            }

            solving = false;
            shuffling = false;

            puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);

            puzzlePieces.forEach((piece, index) => {
                const targetCol = index % gridSize;
                const targetRow = Math.floor(index / gridSize);
                piece.currentX = targetCol * pieceWidth;
                piece.currentY = targetRow * pieceHeight;
            });

            isShuffled = false;
            moves = 0;
            undoStack = [];
            updateMoveCounter();
            stopTimer();
            timerDisplay.textContent = '00:00';
            hasMadeFirstMove = false; // Reset first move flag
            drawPuzzle();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            solveStatusDisplay.textContent = '';

            enableAllButtons();
        });


        // =====================================================================
        // Handle Puzzle Click/Touch (to move pieces)
        // =====================================================================
        puzzleCanvas.addEventListener('click', (event) => {
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling) {
                return;
            }
            isProcessingClick = true;

            // Start timer on first move
            if (!hasMadeFirstMove) {
                hasMadeFirstMove = true;
                startTimer();
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const clickedCol = Math.floor(mouseX / pieceWidth);
            const clickedRow = Math.floor(mouseY / pieceHeight);
            
            const clickedPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (clickedCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (clickedRow * pieceHeight)) < 1
            );
            if (!clickedPiece || clickedPiece.isBlank) {
                isProcessingClick = false;
                return;
            }

            const blankPiece = puzzlePieces.find(p => p.isBlank);
            const clickedPieceCol = Math.round(clickedPiece.currentX / pieceWidth);
            const clickedPieceRow = Math.round(clickedPiece.currentY / pieceHeight);
            const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
            const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

            const isAdjacent = (
                (Math.abs(clickedPieceCol - blankPieceCol) === 1 && clickedPieceRow === blankPieceRow) ||
                (Math.abs(clickedPieceRow - blankPieceRow) === 1 && clickedPieceCol === blankPieceCol)
            );
            if (isAdjacent) {
                const currentStatePieces = puzzlePieces.map(p => ({ ...p }));
                undoStack.push({ pieces: currentStatePieces, moves: moves, isShuffled: isShuffled, puzzleMode: currentPuzzleMode });
                if (undoStack.length > maxUndoStates) {
                    undoStack.shift();
                }

                const targetXForClicked = blankPiece.currentX;
                const targetYForClicked = blankPiece.currentY;
                const targetXForBlank = clickedPiece.currentX;
                const targetYForBlank = clickedPiece.currentY;
                animatePieceMove(
                    clickedPiece, targetXForClicked, targetYForClicked,
                    blankPiece, targetXForBlank, targetYForBlank,
                    () => {
                        clickedPiece.currentX = targetXForClicked;
                        clickedPiece.currentY = targetYForClicked;
                        blankPiece.currentX = targetXForBlank;
                        blankPiece.currentY = targetYForBlank;

                        const clickedIndexInArray = puzzlePieces.indexOf(clickedPiece);
                        const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                        [puzzlePieces[clickedIndexInArray], puzzlePieces[blankIndexInArray]] = 
                        [puzzlePieces[blankIndexInArray], puzzlePieces[clickedIndexInArray]];

                        moves++;
                        updateMoveCounter();
                        drawPuzzle();
                        checkWin();
                        isProcessingClick = false;
                    }
                );
            } else {
                isProcessingClick = false;
            }
        });

        // =====================================================================
        // Handle Mouse Hover (for visual effects)
        // =====================================================================
        puzzleCanvas.addEventListener('mousemove', (event) => {
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling) {
                if (hoveredPiece) {
                    hoveredPiece = null;
                    drawPuzzle();
                }
                return;
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const currentHoverCol = Math.floor(mouseX / pieceWidth);
            const currentHoverRow = Math.floor(mouseY / pieceHeight);

            const potentialHoveredPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (currentHoverCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (currentHoverRow * pieceHeight)) < 1
            );
            if (potentialHoveredPiece && potentialHoveredPiece !== hoveredPiece && !potentialHoveredPiece.isBlank) {
                hoveredPiece = potentialHoveredPiece;
                drawPuzzle();
            } else if (!potentialHoveredPiece && hoveredPiece) {
                hoveredPiece = null;
                drawPuzzle();
            } else if (potentialHoveredPiece && potentialHoveredPiece.isBlank && hoveredPiece) {
                hoveredPiece = null;
                drawPuzzle();
            }
        });
        puzzleCanvas.addEventListener('mouseleave', () => {
            if (hoveredPiece) {
                hoveredPiece = null;
                drawPuzzle();
            }
        });
        // =====================================================================
        // Piece Movement Animation Function (for manual & auto-solve moves)
        // =====================================================================
        function animatePieceMove(piece1, targetX1, targetY1, piece2, targetX2, targetY2, callback) {
            const startX1 = piece1.currentX;
            const startY1 = piece1.currentY;
            const startX2 = piece2.currentX;
            const startY2 = piece2.currentY;

            let startTime = null;
            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                piece1.currentX = startX1 + (targetX1 - startX1) * progress;
                piece1.currentY = startY1 + (targetY1 - startY1) * progress;
                piece2.currentX = startX2 + (targetX2 - startX2) * progress;
                piece2.currentY = startY2 + (targetY2 - startY2) * progress;
                
                drawPuzzle();
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    callback();
                }
            }
            requestAnimationFrame(animate);
        }

        // =====================================================================
        // Update Move Counter
        // =====================================================================
        function updateMoveCounter() {
            moveCounterDisplay.textContent = moves;
        }

        // =====================================================================
        // Timer Functions
        // =====================================================================
        function startTimer() {
            stopTimer();
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimer() {
            const elapsedTime = Date.now() - startTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');

            timerDisplay.textContent = `${formattedMinutes}:${formattedSeconds}`;
        }

        // =====================================================================
        // Check Win Condition & Display Win Animation
        // =====================================================================
        function checkWin() {
            if (!isShuffled) return;
            let solved = true;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                // Check if the piece is in its correct original position
                const currentPieceCol = Math.round(piece.currentX / pieceWidth);
                const currentPieceRow = Math.round(piece.currentY / pieceHeight);
                const currentPieceIndex = currentPieceRow * gridSize + currentPieceCol;
                if (piece.id !== currentPieceIndex) {
                    solved = false;
                    break;
                }
            }

            if (solved) {
                isShuffled = false;
                stopTimer();
                hasMadeFirstMove = false; // Reset first move flag

                // Ensure the blank piece is visually at the last position for a truly solved look
                const blankPiece = puzzlePieces.find(p => p.isBlank);
                const blankPieceCurrentIndexInArray = puzzlePieces.indexOf(blankPiece);
                const lastCorrectArrayPosition = puzzlePieces.length - 1;
                if (blankPieceCurrentIndexInArray !== lastCorrectArrayPosition) {
                    const pieceAtLastPosition = puzzlePieces[lastCorrectArrayPosition];
                    puzzlePieces[lastCorrectArrayPosition] = blankPiece;
                    puzzlePieces[blankPieceCurrentIndexInArray] = pieceAtLastPosition;

                    blankPiece.currentX = (lastCorrectArrayPosition % gridSize) * pieceWidth;
                    blankPiece.currentY = Math.floor(lastCorrectArrayPosition / gridSize) * pieceHeight;
                    pieceAtLastPosition.currentX = (blankPieceCurrentIndexInArray % gridSize) * pieceWidth;
                    pieceAtLastPosition.currentY = Math.floor(blankPieceCurrentIndexInArray / gridSize) * pieceHeight;
                }
                
                drawPuzzle();
                puzzleCanvas.classList.add('puzzle-solved-animation'); // Apply bounce animation
                
                showMessageBox(`Selamat! Puzzle telah selesai dalam ${moves} gerakan dan waktu ${timerDisplay.textContent}!`);
                enableAllButtons();
                solving = false;
                shuffling = false;
                isProcessingClick = false;
                solveStatusDisplay.textContent = '';
            }
        }

        // =====================================================================
        // Disable all interactive buttons
        // =====================================================================
        function disableAllButtons() {
            shuffleButton.disabled = true;
            undoButton.disabled = true;
            solveButton.disabled = true;
            resetButton.disabled = false; // Reset button always remains active
            imageUpload.disabled = true;
            gridSizeSelect.disabled = true;
            puzzleModeSelect.disabled = true;
            viewOriginalImageButton.disabled = true;
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'none');
            sampleImageContainers.forEach(container => container.style.opacity = '0.5');
        }

        // =====================================================================
        // Enable all interactive buttons
        // =====================================================================
        function enableAllButtons() {
            shuffleButton.disabled = false;
            undoButton.disabled = false;
            solveButton.disabled = false; 
            resetButton.disabled = false;
            imageUpload.disabled = false;
            gridSizeSelect.disabled = false;
            puzzleModeSelect.disabled = false;
            viewOriginalImageButton.disabled = false;
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'auto');
            sampleImageContainers.forEach(container => container.style.opacity = '1');
        }

        // =====================================================================
        // Function to auto-solve puzzle using BFS (Breadth-First Search)
        // =====================================================================
        async function solvePuzzleAutomatically() {
            if (!puzzleReady || !isShuffled || solving || shuffling) {
                return;
            }

            solving = true;
            isProcessingClick = true;
            hasMadeFirstMove = true; // Auto-solve implies moves are being made, so start timer
            startTimer();
            if (gridSize === 5) {
                solveStatusDisplay.textContent = `Peringatan: 5x5 Otomatis Sangat Lambat! Harap Bersabar.`;
            } else {
                solveStatusDisplay.textContent = `Mencari solusi otomatis...`;
            }
            
            disableAllButtons();
            resetButton.disabled = false;

            stopTimer(); // Temporarily stop timer during search, will restart for animation playback

            const queue = [];
            const visited = new Set();

            // Create a state array based on current positions (map original IDs to their current 1D index)
            const initialPiecesState = puzzlePieces.map(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                return { id: p.id, currentPos: row * gridSize + col };
            });
            initialPiecesState.sort((a, b) => a.currentPos - b.currentPos); // Sort by current position to get current "reading" order

            const initialOrderedIds = initialPiecesState.map(p => p.id);
            const blankId = puzzlePieces.find(p => p.isBlank).id;
            const initialBlankPos = initialOrderedIds.indexOf(blankId);

            queue.push({ state: initialOrderedIds, path: [], blankPos: initialBlankPos });
            visited.add(JSON.stringify(initialOrderedIds));
            let solutionPath = null;
            let count = 0; 

            while (queue.length > 0 && solving && count < maxStatesToExploreForBFS) {
                const { state, path, blankPos } = queue.shift();
                count++;

                const isSolved = state.every((id, index) => id === index);
                if (isSolved) {
                    solutionPath = path;
                    break;
                }

                const blankRow = Math.floor(blankPos / gridSize);
                const blankCol = blankPos % gridSize;

                const possibleSwapPositions = [];
                // Check neighbors: Up, Down, Left, Right
                if (blankRow > 0) possibleSwapPositions.push(blankPos - gridSize);
                if (blankRow < gridSize - 1) possibleSwapPositions.push(blankPos + gridSize); 
                if (blankCol > 0) possibleSwapPositions.push(blankPos - 1);
                if (blankCol < gridSize - 1) possibleSwapPositions.push(blankPos + 1); 

                for (const pieceToSwapIndex of possibleSwapPositions) {
                    const nextState = [...state];
                    // Swap the IDs in the new state array
                    const tempId = nextState[blankPos];
                    nextState[blankPos] = nextState[pieceToSwapIndex];
                    nextState[pieceToSwapIndex] = tempId;

                    const nextStateStr = JSON.stringify(nextState);
                    if (!visited.has(nextStateStr)) {
                        visited.add(nextStateStr);
                        queue.push({
                            state: nextState,
                            path: [...path, state[pieceToSwapIndex]], // Store the ID of the piece that moved into the blank spot
                            blankPos: pieceToSwapIndex 
                        });
                    }
                }
                if (count % 1000 === 0) { 
                    await new Promise(resolve => setTimeout(resolve, 0));
                    if (!solving) break; 
                }
            }

            if (!solving) { // If user cancelled auto-solve
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                return;
            }

            if (solutionPath) {
                solveStatusDisplay.textContent = `Solusi ditemukan! Memainkan ${solutionPath.length} gerakan...`;
                const currentAutoSolveDelay = getAutoSolveStepDelay(gridSize);
                
                // Re-start timer for animation playback
                startTimer();
                for (const pieceIdToMove of solutionPath) {
                    if (!solving) break; // Allow cancellation during playback

                    const pieceToMove = puzzlePieces.find(p => p.id === pieceIdToMove);
                    const blankPiece = puzzlePieces.find(p => p.isBlank);

                    if (!pieceToMove || !blankPiece) { 
                        console.error("Error: Piece or blank not found during auto-solve execution.");
                        solving = false;
                        isProcessingClick = false;
                        enableAllButtons();
                        solveStatusDisplay.textContent = 'Terjadi kesalahan saat memainkan solusi.';
                        stopTimer(); // Stop timer on error
                        hasMadeFirstMove = false;
                        return;
                    }
                    
                    const startX1 = pieceToMove.currentX;
                    const startY1 = pieceToMove.currentY;
                    const startX2 = blankPiece.currentX;
                    const startY2 = blankPiece.currentY;

                    const targetX1 = startX2; 
                    const targetY1 = startY2;
                    const targetX2 = startX1; 
                    const targetY2 = startY1; 

                    await new Promise(resolve => {
                        animatePieceMove(
                            pieceToMove, targetX1, targetY1,
                            blankPiece, targetX2, targetY2,
                            () => {
                                pieceToMove.currentX = targetX1;
                                pieceToMove.currentY = targetY1;
                                blankPiece.currentX = targetX2;
                                blankPiece.currentY = targetY2;

                                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                                const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                                [puzzlePieces[pieceToMoveCurrentIndex], puzzlePieces[blankIndexInArray]] =
                                [puzzlePieces[blankIndexInArray], puzzlePieces[pieceToMoveCurrentIndex]];

                                moves++;
                                updateMoveCounter();
                                drawPuzzle();
                                resolve();
                            }
                        );
                    });
                    if (solving) { // Only pause if solving is still active
                        await new Promise(resolve => setTimeout(resolve, currentAutoSolveDelay));
                    }
                }
                if (solving) {
                    checkWin(); // Final check if solution playback completed
                }
            } else { 
                solveStatusDisplay.textContent = 'Solusi tidak ditemukan dalam batas waktu/komputasi. Coba acak ulang.';
                showMessageBox('Solusi tidak ditemukan dalam batas waktu atau terlalu kompleks. Coba acak ulang puzzle atau pilih ukuran yang lebih kecil.');
            }

            solving = false;
            isProcessingClick = false;
            enableAllButtons();
            // Timer is handled by checkWin or explicitly stopped on failure/cancellation
            if (isShuffled && !solving) { // If still shuffled and not in an active solve state
                startTimer(); // Ensure timer continues if not solved
            } else if (!isShuffled && !solving) { // If solved, ensure timer is stopped
                stopTimer();
                hasMadeFirstMove = false;
            }
        }
        solveButton.addEventListener('click', solvePuzzleAutomatically);
        // =====================================================================
        // Handle Window Resize Responsiveness
        // =====================================================================
        window.addEventListener('resize', async () => {
            if (!puzzleReady) return; // Don't do anything if puzzle isn't ready

            solving = false;
            isProcessingClick = false;
            // `shuffling` flag is controlled internally by animateShuffle and should not be reset here
            // This allows the shuffle animation to continue uninterrupted by resizes (like scrolling on mobile)
            
            enableAllButtons(); // Re-enable in case they were disabled by auto-solve/click animation
            // Removed: stopTimer(); // REMOVED: This was causing the timer to stop on mobile scroll
            solveStatusDisplay.textContent = '';
            puzzleCanvas.classList.remove('puzzle-solved-animation'); // Clear win animation

            recalculatePiecePositionsAndRedraw(); // Always redraw to fit new canvas size, preserving current state
        });
        // =====================================================================
        // Local Storage Functions for Preferences
        // =====================================================================
        function savePreferences() {
            localStorage.setItem('puzzleGridSize', gridSizeSelect.value);
            localStorage.setItem('puzzleMode', puzzleModeSelect.value);
        }

        function loadPreferences() {
            const savedGridSize = localStorage.getItem('puzzleGridSize');
            const savedPuzzleMode = localStorage.getItem('puzzleMode');

            if (savedGridSize) {
                gridSizeSelect.value = savedGridSize;
                gridSize = parseInt(savedGridSize);
            }
            if (savedPuzzleMode) {
                puzzleModeSelect.value = savedPuzzleMode;
                currentPuzzleMode = savedPuzzleMode;
            }
        }

        // =====================================================================
        // Handle "View Original Image" Button
        // =====================================================================
        viewOriginalImageButton.addEventListener('click', () => {
            if (originalImage.src) {
                fullImageDisplay.src = originalImage.src;
                mainContent.classList.add('main-content-hidden'); // Hide main puzzle UI
                originalImageDisplayContainer.classList.add('show'); // Show original image container
                // Scroll to the top of the original image container
                originalImageDisplayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                showMessageBox("Tidak ada gambar yang dimuat untuk ditampilkan.");
            }
        });
        backToPuzzleButton.addEventListener('click', () => {
            originalImageDisplayContainer.classList.remove('show'); // Hide original image container
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            // Scroll to the puzzle canvas for better context
            puzzleCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' }); // block: 'center' tries to center it
        });
        // =====================================================================
        // Initial Page Load Setup (placeholder image)
        // =====================================================================
        window.onload = async () => {
            loadPreferences(); // Load saved preferences first
            originalImage.onload = async () => {
                initializePuzzle();
                drawPuzzle(); // Ensure it draws the solved placeholder
                // Timer starts only after first shuffle/move
            };
            const placeholderSize = 600; 
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`; 
        };

    </script>
</body>
</html>
